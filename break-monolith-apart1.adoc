= Lab3 - モノリスをバラバラにする - I
:experimental:


以前のラボでは、既存のモノリシックな Java EE アプリケーションを JBoss EAP と OpenShift を使用してクラウドに移行する方法を学びました。そして、既存のアプリケーションに対する OpenShift の威力を垣間見ることができました。

これで、アプリケーションを異なる技術を使って複数のマイクロサービスに分解し、アプリケーションを近代化するプロセスを開始できます。これは、分散マイクロサービスのセットとしてアプリケーション全体を再設計することを最終的な目標としています。後ほど、アプリケーションが再アーキテクトされた後に、どのようにしてより良い管理と監視ができるかを探っていきます。

このラボでは、 https://quarkus.io/[Quarkus^] を使って _Supersonic（超音速）、Subatomic（粒子並みに小さい）、Java_ について学びます。これはコンテナと開発者が使いやすいように設計されています。

Quarkus は、 _Kubernetes ネイティブ_ Java スタックであり、最高の Java ライブラリと標準規格から作られています。驚くほど高速な起動時間、信じられないほど低い RSS メモリ（ヒープサイズだけではありません！）を提供し、Kubernetes のようなコンテナオーケストレーションプラットフォームで、ほぼ瞬時にスケールアップし、高密度のメモリ利用を実現します。Quarkus はコンパイルタイムブートと呼ばれる技術を使用しています。 

*Red Hat* では、Quarkus のサポートと保守が完全にサポートされた https://access.redhat.com/products/quarkus[Red Hat Build of Quarkus(RHBQ)^] を提供しています。このワークショップでは、Quarkus を使用して Kubernetes ネイティブのマイクロサービスを開発し、OpenShift にデプロイします。Quarkus は https://www.redhat.com/en/products/runtimes[Red Hat Runtimes^] に含まれるランタイムの 1 つです。 https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus[RHBQについてはこちらをご覧ください^]。

=== このラボの目標

モノリスの 1 つのコンポーネントを Quarkus マイクロサービスとして実装します。この修正は、マイクロサービスの懸念に対処するためにそれを修正し、その構造を理解し、OpenShift にデプロイし、Quarkus アプリ、マイクロサービス、OpenShift/Kubernetes の間のインターフェイスを行使します。

目標は、この新しいマイクロサービスを既存のモノリスと一緒にデプロイし、後でそれらを結びつけることです。でも、このラボの後には、次のようなものが完成するはずです。

image::goal.png[lab3_goal, 700]

==== 1. 在庫プロジェクトの設定

以下のコマンドを実行して、このラボの環境を設定し、正しいディレクトリで起動します。

プロジェクト・エクスプローラで、*inventory* プロジェクトを展開します。

image::codeready-workspace-inventory-project.png[inventory_setup, 700]

==== 2. Maven プロジェクトの構造を調査

サンプルの Quarkus プロジェクトでは、いくつかのエンドポイントを REST で公開している最小限の CRUD サービスを示しています。Angular をベースにしたフロントエンドが付いているのでブラウザから遊べます。

コードは驚くほどシンプルですが、内部では以下を使用しています。

* REST エンドポイントを公開するための RESTEasy
* Hibernate ORM with Panache でデータベースの CRUD 操作を実行
* PostgreSQL データベース; Linux コンテナを介して実行するには下部を参照
* JVMとネイティブモードのコンパイル用に新しいイメージを生成するための `Dockerfiles` の例をいくつか紹介します。

`Hibernate ORM` は事実上の JPA 実装であり、オブジェクトリレーショナルマッパーの全幅を提供します。複雑なマッピングを可能にしますが、単純で一般的なマッピングをつまらなくするものではありません。Hibernate ORM with Panache は、Quarkus で書くのが楽しくなるように、エンティティを些細なものにすることに焦点を当てています。

それでは、いくつかのコードを書いて、ドメインモデル、サービスインターフェース、インベントリにアクセスするための RESTful エンドポイントを作成してみましょう。

image::inventory-arch.png[Inventory RESTful Service, 700]

==== 3. Quarkusの拡張機能を追加

_Panache_ （Hibernate ORM 経由でデータにアクセスするための簡略化された方法）を使用するための 在庫アプリケーションに Quarkus の拡張機能を追加します。これは Postgres （本番用）と _H2_ （テスト用のインメモリデータベース）を使ったデータベースです。また、MicroProfile Health 拡張機能を使用して、ヘルスプローブを追加する機能も追加します (これは後ほど使用します)。CodeReady Terminal を使用して以下のコマンドを実行して、拡張機能を追加します。

[source,sh,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="hibernate-orm-panache, jdbc-h2, smallrye-health" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/inventory
----

あなたは以下を見られます。

[source,sh]
----
✅ Extension io.quarkus:quarkus-hibernate-orm-panache has been installed
✅ Extension io.quarkus:quarkus-smallrye-health has been installed
✅ Extension io.quarkus:quarkus-jdbc-h2 has been installed
----

そして、これは `pom.xml` に拡張機能を追加します。

[NOTE]
====
Quarkus 用の https://vertx.io/[Vert.x^]、 http://camel.apache.org/[Apache Camel^]、 http://infinispan.org/[Infinispan^]、Spring （ `@Autowired` など）に加えて人気フレームワーク用の https://quarkus.io/extensions/[さらなる拡張機能^] がたくさんあります。
====

==== 4. 在庫エンティティの作成

スケルトンプロジェクトができたので、ビジネスロジックの定義に取り掛かりましょう。

まず、在庫オブジェクトのモデル（実体）を定義する。Quarkus は Hibernate ORM Panache を使用しているので、モノリシックアプリケーションから同じモデル定義を再利用できます。書き直しや再設計の必要はありません。

`inventory` ディレクトリの下で、 _com.redhat.coolstore_ パッケージの中の空の *Inventory.java* ファイルを開き、そこに以下のコードを貼り付けます（モノリスのコードと同じ）。

[source,java, role="copypaste"]
----
package com.redhat.coolstore;

import javax.persistence.Cacheable;
import javax.persistence.Entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity
@Cacheable
public class Inventory extends PanacheEntity {

    public String itemId;
    public String location;
    public int quantity;
    public String link;

    public Inventory() {

    }

}
----

`PanacheEntity` をあなたのエンティティで拡張することで、自動生成される ID フィールドが得られます。カスタム ID 戦略が必要な場合は、代わりに `PanacheEntityBase` を拡張して自分で ID を対応できます。

パブリックフィールドを使用することで、ゲッターやセッターといったメソッド（単にフィールドを取得したり設定したりするだけのもの）は不要になります。Inventory.getLocation() の実装を書かなくても、Inventory.location のようなフィールドを参照するだけです。Panacheは、あなたが書いていないゲッターやセッターを自動生成します。また、取得/設定以上の機能を持つ独自のゲッター/セッターの開発もできます。これらは、フィールドに直接アクセスしたときに呼び出されます。

`PanacheEntity` スーパークラスには多くの便利な static メソッドがあります。あなたは派生エンティティクラスに独自のメソッドを追加できます。伝統的なオブジェクト指向プログラミングと同様に、それは自然なことです。これはカスタムクエリを可能な限りエンティティに近づけ、理想的にはエンティティ定義自体の中に配置することを推奨しています。ユーザーは、Inventory と入力するだけで、エンティティ Inventory の使用を開始でき、すべての操作の完了を一箇所で得ることができます。

エンティティが `@Cacheable` でアノテーションされている場合、コレクションと他のエンティティとの関係を除いて、すべてのフィールド値がキャッシュされます。つまり、頻繁にアクセスされるが、めったに変化しないデータをデータベースに問い合わせることなく、エンティティをより迅速にロードすることができるということです。

==== 5. 在庫の RESTful エンドポイントの定義

このステップでは、 _サービス_ の抽象化を正確に描画します。ということで、将来的には在庫 _サービス_ を様々な場所（RESTful リソースのエンドポイントのような）に注入できるようになります。これは私たちのモノリスが使っているのと同じアプローチなので、このアイデアを再利用することができます。 _com.redhat.coolstore_ パッケージ内の空の *InventoryResource.java* クラスを開きます。

以下のコードを追加します。

[source,java, role="copypaste"]
----
package com.redhat.coolstore;

import java.util.List;
import java.util.stream.Collectors;

import javax.enterprise.context.ApplicationScoped;
import javax.json.Json;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.ext.ExceptionMapper;
import javax.ws.rs.ext.Provider;

import org.jboss.resteasy.annotations.jaxrs.PathParam;

@Path("/services/inventory")
@ApplicationScoped
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class InventoryResource {

    @GET
    public List<Inventory> getAll() {
        return Inventory.listAll();
    }

    @GET
    @Path("/{itemId}")
    public List<Inventory> getAvailability(@PathParam String itemId) {
        return Inventory.<Inventory>streamAll()
        .filter(p -> p.itemId.equals(itemId))
        .collect(Collectors.toList());
    }

    @Provider
    public static class ErrorMapper implements ExceptionMapper<Exception> {

        @Override
        public Response toResponse(Exception exception) {
            int code = 500;
            if (exception instanceof WebApplicationException) {
                code = ((WebApplicationException) exception).getResponse().getStatus();
            }
            return Response.status(code)
                    .entity(Json.createObjectBuilder().add("error", exception.getMessage()).add("code", code).build())
                    .build();
        }

    }
}
----

上記の REST サービスでは、2つのエンドポイントを定義しています。

* `/services/inventory` これは、すべての既知の製品在庫の実体をJSONとして返す。 _HTTP GET_ 経由でアクセス可能です。
* `/services/inventory/<itemId>` これは _HTTP GET_ 経由でアクセスできます。例えば `services/inventory/329199` で、最後のパスのパラメータには在庫の状態を知りたいIDを指定します。

==== 6. 在庫データの追加

データベースに在庫データを追加して、テストできるようにしておきましょう。 `src/main/resources/import.sql` ファイルを開き、以下の SQL 文を *import.sql* にコピーします。

[source,sql, role="copypaste"]
----
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '329299', 'http://maps.google.com/?q=Raleigh', 'Raleigh', 736);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '329199', 'http://maps.google.com/?q=Boston', 'Boston', 512);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '165613', 'http://maps.google.com/?q=Seoul', 'Seoul', 256);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '165614', 'http://maps.google.com/?q=Singapore', 'Singapore', 54);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '165954', 'http://maps.google.com/?q=London', 'London', 87);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '444434', 'http://maps.google.com/?q=NewYork', 'NewYork', 443);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '444435', 'http://maps.google.com/?q=Paris', 'Paris', 600);
INSERT INTO INVENTORY (id, itemId, link, location, quantity) values (nextval('hibernate_sequence'), '444437', 'http://maps.google.com/?q=Tokyo', 'Tokyo', 230);
----

開発環境では、ローカル環境でテストするためローカルのインメモリ H2 データベースを使用するように設定します。これらの行を `src/main/resources/application.properties` に追加します。

[source,properties,role="copypaste"]
----
%dev.quarkus.datasource.url=jdbc:h2:mem:inventory
%dev.quarkus.datasource.driver=org.h2.Driver
%dev.quarkus.datasource.username=inventory
%dev.quarkus.datasource.password=mysecretpassword
%dev.quarkus.datasource.max-size=8
%dev.quarkus.datasource.min-size=2
%dev.quarkus.hibernate-orm.database.generation=drop-and-create
%dev.quarkus.hibernate-orm.log.sql=false
----

==== 7. Quarkus 在庫アプリケーションを実行する

ターミナルで、 _ライブ コーディング_ モードでプロジェクトを実行します。

[source,sh,role="copypaste"]
----
mvn quarkus:dev -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/inventory
----

以下で終わるログ出力の束が表示されるはずです。

[source,console]
----
2020-03-19 14:41:17,171 INFO  [io.agr.pool] (main) Datasource '<default>': Initial size smaller than min. Connections will be created when necessary
2020-03-19 14:41:17,454 INFO  [io.quarkus] (main) inventory 1.0-SNAPSHOT (running on Quarkus xx.xx.xx) started in 3.353s. Listening on: http://0.0.0.0:8080
2020-03-19 14:41:17,457 INFO  [io.quarkus] (main) Profile dev activated. Live Coding activated.
2020-03-19 14:41:17,457 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, hibernate-orm, hibernate-orm-panache, jdbc-h2, narayana-jta, resteasy, resteasy-jsonb, smallrye-health]
----

CodeReady は、Quarkus アプリが `5005` 番ポート（デバッグ用）と `8080` 番ポート（Webリクエスト用）を開いていることも検出します。5005 番ポートは開かず、プロンプトが表示されたら `8080` 番ポートを開き、CodeReady で小さな Web ブラウザを開きます。

image::open-port.png[Inventory RESTful Service, 700]

CodeReady で在庫の Web フロントエンドを直接見ることができるはずです( _リロード_ アイコンをクリックする必要があるかもしれません)。

image::inventory-codeready.png[Inventory RESTful Service, 700]

*新しい* CodeReady Workspaces Terminal を開きます。

image::codeready-workspace-terminal.png[Inventory RESTful Service, 700]

以下の CURL コマンドを使用して RESTful エンドポイントを呼び出します。

[source,sh,role="copypaste"]
----
curl http://localhost:8080/services/inventory | jq
----

出力はこんな感じです。

[source,json]
----
  ...
  {
    "id": 7,
    "itemId": "444435",
    "link": "http://maps.google.com/?q=Paris",
    "location": "Paris",
    "quantity": 600
  },
  {
    "id": 8,
    "itemId": "444437",
    "link": "http://maps.google.com/?q=Tokyo",
    "location": "Tokyo",
    "quantity": 230
  }
----

==== 8. ヘルスプローブの追加

===== MicroProfile Healthとは何ですか？

*MicroProfile Health* は、アプリケーションがその状態に関する情報を外部のビューアに提供することを可能にします。これは通常、アプリケーションを破棄するか再起動するかを自動プロセスが判断できるようにしなければならない OpenShift のようなクラウド環境で有用です。

===== ヘルスチェックを実行

先に _health 拡張機能_ をインポートした場合、ヘルスチェックの手順を実行するために使用できる `/health` エンドポイントが自動的に直接公開されます。

アプリケーションはまだ実行中なので、別のターミナルでこのコマンドを使ってデフォルトの (何もしない) ヘルスチェックを実行できます。

[source,sh,role="copypaste"]
----
curl -s http://localhost:8080/health | jq
----

以下の出力が表示されます。

[source,json]
----
{
  "status": "UP",
  "checks": [
    {
      "name": "Database connections health check",
      "status": "UP"
    }
  ]
}
----

ヘルスチェックの一般的な _結果_ は、宣言されたすべてのヘルスチェック手順の論理 AND として計算されます。また、Quarkus の拡張機能では、デフォルトのヘルスチェック機能も提供されています。今回、データベース拡張モジュールを使用しているので、上の `Database connections health check（データベース接続のヘルスチェック）` が表示される理由です。

==== 9. 初めてのヘルスチェックを作成

次に、新しい RESTful エンドポイントを作成してクラスを埋めてみましょう。これは OpenShift でサービスをプローブするために使用されます。空のJavaクラス: `src/main/java/com/redhat/coolstore/InventoryHealthCheck.java` を開き、以下のコードを追加します。

[source,java,role="copypaste"]
----
package com.redhat.coolstore;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Readiness;

@Readiness
@ApplicationScoped
public class InventoryHealthCheck implements HealthCheck {

    @Inject
    private InventoryResource inventoryResource;

    @Override
    public HealthCheckResponse call() {

        if (inventoryResource.getAll() != null) {
            return HealthCheckResponse.named("Success of Inventory Health Check!!!").up().build();
        } else {
            return HealthCheckResponse.named("Failure of Inventory Health Check!!!").down().build();
        }
    }
}
----

`call()` メソッドは HTTP GET エンドポイントを公開します。これはサービスの状態を返します。このチェックのロジックは、基盤となるデータベースへの接続が安定しており、利用可能であることを確認するために、簡単なクエリを実行します。また、このメソッドには MicroProfile の `@Readiness` アノテーションが付けられています。これは、Quarkus がこのエンドポイントを `/health/ready` のヘルスチェックとして公開するように指示します。

[NOTE]
====
在庫アプリケーションを停止して再実行する必要はありません。なぜなら、Quarkus は _ライブコーディング_ 機能を介して *自動的に変更をリロードする* からです。
====

_curl_ を使用して再度ヘルスエンドポイントにアクセスすると、結果は次のようになります。

[source,sh,role="copypaste"]
----
curl -s http://localhost:8080/health | jq
----

以下の結果が出るはずです。

[source,json]
----
{
  "status": "UP",
  "checks": [
    {
      "name": "Success of Inventory Health Check!!!",
      "status": "UP"
    },
    {
      "name": "Database connections health check",
      "status": "UP"
    }
  ]
}
----

これでデフォルトのヘルスチェックと新しい在庫のヘルスチェックが表示されます。

[NOTE]
====
`@Liveness` アノテーションと `@Readiness` アノテーションを使用して、個別のライブネスプローブとレディネスプローブを定義できます。そして、これは `/health/live` と `/health/ready` で別々にそれらにアクセスします。
====

===== 清掃

アプリが実行されているターミナルで kbd:[CTRL-C] と入力して Quarkus アプリを停止します。

==== 10. OpenShiftプロジェクトの作成

このステップでは、CoolStore アプリケーション用の新しい在庫マイクロサービスを別のプロジェクトにデプロイして、それを格納します。これにより、モノリスや後に作成する他のマイクロサービスとは切り離された状態になります。

OpenShift コンソールに行く前に、PostgreSQL の拡張機能を追加するための Quarkus アプリケーションを再パッケージします。なぜなら、在庫サービスは OpenShift 上の本番環境で PostgeSQL データベースに接続するからです。

また、Quarkus では、健全なデフォルト設定とユーザーが提供する設定に基づいて OpenShift リソースを自動的に生成する機能も提供しています。OpenShift 拡張機能は、実際には https://quarkus.io/guides/deploying-to-kubernetes[kubernetes^] 拡張機能と https://quarkus.io/guides/container-image#s2i[container-image-s2i^] 拡張機能をデフォルトでまとめたラッパー拡張です。これにより、ユーザーが OpenShift 上で Quarkus を使い始めるのが簡単になります。

CodeReady Workspaces Terminal 経由で _quarkus-jdbc-postgresql_ と _openshift_ 拡張機能を追加します。

[source,sh,role="copypaste"]
----
mvn -q quarkus:add-extension -Dextensions="jdbc-postgresql,openshift" -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/inventory
----

あなたを以下を見られます。

[source,sh]
----
✅ Extension io.quarkus:quarkus-openshift has been installed
✅ Extension io.quarkus:quarkus-jdbc-postgresql has been installed
----

Quarkus は、 _設定プロファイル_ の概念をサポートしています。これらは、同じファイル内に複数の設定を持つことができ、 _プロファイル名_ を介して選択できます。

デフォルトでは、Quarkus には 3 つのプロファイルがありますが、好きなだけ使用できます。デフォルトのプロファイルは以下のとおりです。

* `dev` - 開発モードの場合に有効 （例えば *quarkus:dev* ）
* `test` - テストの時に有効
* `prod` - 開発モードまたはテストモードで実行していないときのデフォルトプロファイル

_src/main/resources/application.properties_ に以下の変数を `追加` してみましょう。

[source,shell,role="copypaste"]
----
%prod.quarkus.datasource.url=jdbc:postgresql://inventory-database:5432/inventory
%prod.quarkus.datasource.driver=org.postgresql.Driver
%prod.quarkus.datasource.username=inventory
%prod.quarkus.datasource.password=mysecretpassword
%prod.quarkus.datasource.max-size=8
%prod.quarkus.datasource.min-size=2
%prod.quarkus.hibernate-orm.database.generation=drop-and-create
%prod.quarkus.hibernate-orm.sql-load-script=import.sql
%prod.quarkus.hibernate-orm.log.sql=true
%prod.quarkus.s2i.base-jvm-image=registry.access.redhat.com/ubi8/openjdk-11

%prod.quarkus.kubernetes-client.trust-certs=true<1>
%prod.quarkus.container-image.build=true<2>
%prod.quarkus.kubernetes.deploy=true<3>
%prod.quarkus.kubernetes.deployment-target=openshift<4>
%prod.quarkus.openshift.expose=true<5>
%prod.quarkus.openshift.labels.app.openshift.io/runtime=quarkus<6>
----

<1> この単純な例では自己署名証明書を使用しているので、これは単に拡張機能に信頼するように言っているだけです。
<2> コンテナイメージを構築するように拡張機能に指示します。
<3> コンテナイメージが構築された後、拡張機能をOpenShiftにデプロイするように指示します。 
<4> コンテナを構築した後に OpenShift リソース（ `DeploymentConfig` や `Service` のような）を生成して作成するように拡張機能に指示します。 
<5> OpenShift `Route` を生成するように拡張機能に指示します。
<6> OpenShift Developer Toplogy を表示する際に、アプリに見栄えの良いアイコンを追加します。

OpenShift では、 _Developer_ パースペクティブにいることを確認し、 `{{ USER_ID }}-inventory` プロジェクトを選択します。これはすでにあなたのために作成されています。

まだ何もありませんが、それが変わろうとしています。

==== 11. OpenShiftへのデプロイ

新しい在庫のマイクロサービスを OpenShift にデプロイしよう！

当社の本番の在庫マイクロサービスは、在庫データを格納するために外部データベース（PostgreSQL）を使用します。まず、PostgreSQL の新しいインスタンスをデプロイします。プロジェクト概要の _Database_ ボックスの左側にある **+Add** をクリックします。

image::db.png[db, 700]

検索ボックスに `postgres` と入力し、 *PostgreSQL（ephemeral）* をクリックします。

image::db-postgres.png[db, 700]

*Instantiate Template* をクリックして、以下のフィールドを入力します。他の値をデフォルトのままにしておきます。

* **Namespace**: _最初の名前空間は `{{ USER_ID }}-inventory` を選択し 2 番目の名前空間は `openshift` のままにしておきます_
* **Database Service Name**: `inventory-database`
* **PostgreSQL Connection Username**: `inventory`
* **PostgreSQL Connection Password**: `mysecretpassword`
* **PostgreSQL Database Name**: `inventory`

image::db-postgres-inventory-values.png[db, 700]

*Create* をクリックします。

これにより、データベースが新しいプロジェクトにデプロイされます。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-inventory[Topology View^] をクリックすると表示されます。

image::inventory-database-deployment.png[inventory_db_deployments, 700]

==== 12. OpenShift へのデプロイ

では、アプリケーション自体をデプロイしてみましょう。以下のコマンドを実行すると、OpenShift 拡張機能を使用してビルドとデプロイを行います。

[source,sh,role="copypaste"]
----
oc project {{ USER_ID }}-inventory && \
mvn clean package -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/inventory
----

出力は `BUILD SUCCESS` で終わるはずです。

最後に、実際に起動が完了したことを確認してください。

[source,sh,role="copypaste"]
----
oc rollout status -w dc/inventory
----

*レプリケーションコントローラの _inventory-1_ が正常に起動されたこと* を報告するコマンドを待ってから続行します。

そして、アイテムには適切なアイコンでラベルを貼ります。

[source,sh,role="copypaste"]
----
oc label dc/inventory-database app.openshift.io/runtime=postgresql --overwrite && \
oc label dc/inventory app.kubernetes.io/part-of=inventory --overwrite && \
oc label dc/inventory-database app.kubernetes.io/part-of=inventory --overwrite && \
oc annotate dc/inventory app.openshift.io/connects-to=inventory-database --overwrite && \
oc annotate dc/inventory app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m1-labs.git --overwrite && \
oc annotate dc/inventory app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-inventory[Topology View^] に戻って、デプロイが完了していることを確認します（紺色の丸）。

image::inventory-rollout.png[inventory_db_deployments, 700]

上の Route アイコン（矢印）をクリックすると、OpenShift 上で稼働している在庫にアクセスできます。

image::inventory-web.png[web, 700]

UI は 2 秒ごとに在庫リテーブルを更新します。

また、ターミナルの _curl_ を使用して _在庫_ のエンドポイントでヘルスチェックロジックにアクセスできるようにしておく必要があります。

[source,sh,role="copypaste"]
----
curl $(oc get route inventory -o jsonpath={% raw %}"{.spec.host}"{% endraw %})/health/ready | jq
----

同じJSONレスポンスを使用する必要があります。

[source,json]
----
{
  "status": "UP",
  "checks": [
    {
      "name": "Database connections health check",
      "status": "UP"
    },
    {
      "name": "Success of Inventory Health Check!!!",
      "status": "UP"
    }
  ]
}
----

==== 13. プローブのタイムアウトを調整

プローブの様々なタイムアウト値は、いくつかの方法で設定できます。 _レディネスプローブ_ の初期遅延を調整して、30 秒待ってから起動するようにしましょう。 _oc_ コマンドを使用して、プローブのポーリングを開始する前に 30 秒間待つようにプローブを調整します。

[source,sh,role="copypaste"]
----
oc set probe dc/inventory --readiness --initial-delay-seconds=30
----

そして、CodeReady Workspaces Terminal で変更されたことを確認します（レディネスプローブの _delay=_ の値を見てください）。

[source,sh,role="copypaste"]
----
oc describe dc/inventory | egrep 'Readiness|Liveness'
----

結果が出ました。

[source,console]
----
    Readiness:          http-get http://:8080/health/ready delay=30s timeout=1s period=10s #success=1 #failure=3
----

次のステップでは、プローブを行使して失敗し、OpenShift がアプリケーションを回復するのを見守ります。

==== 14. ヘルスチェックの練習

http://inventory-{{ USER_ID }}-inventory.{{ ROUTE_SUBDOMAIN}}[在庫 UI^] を開きます。

これにより、新しいブラウザタブでサンプルアプリケーションの UI が開きます。

image::app.png[App UI, 700]

アプリは以前と同様にインベントリのポーリングを開始し、成功を報告します。

image::inventory.png[Greeting, 700]

これでサービスが破損し、ヘルスチェックが失敗し始める原因になるでしょう。アプリのクラッシュをシミュレートするために、基礎となるサービスを kill して反応しなくなるようにしてみましょう。CodeReady Workspaces Terminal 経由で実行します。

[source,sh,role="copypaste"]
----
oc rsh dc/inventory kill 1
----

これは、コンテナ内で実行中のJavaプロセスを停止するために Linux の *pkill* コマンドを実行します。

アプリケーションのサンプル UI ページをチェックして、在庫データへのアクセスに失敗していることに気付きます。 _最後に成功したフェッチ_ カウンタが増加し始め、UI がインベントリにアクセスできないことを示しています。これは、サーバの過負荷、コードのバグ、またはアプリケーションを不健全な状態にする他の理由によって引き起こされた可能性があります。

image::inventory-fail.png[Greeting, 700]

{{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-inventory[Topology View^] に戻ると、ポッドが失敗していることがわかります（水色または黄色の警告している丸）。

image::notready.png[Not Ready, 700]

ヘルスチェックのプローブに失敗しすぎた後、OpenShift はサービスを実行しているポッドとコンテナを強制的に殺し、新しいものに置き換えて、その場所に移動します。これが発生すると、水色または黄色の警告円が濃紺色に戻るはずです。これには 30 秒ほどかかります。

同じサンプルアプリの UI （ページをリロードせずに）に戻り、UI が自動的に新しいサービスに再接続し、再び在庫にアクセスすることに成功したことに気づきます。

image::inventory.png[Greeting, 700]

プローブをより適切な値に戻しましょう。

[source,sh,role="copypaste"]
----
oc set probe dc/inventory --readiness --initial-delay-seconds=5 --period-seconds=5 --failure-threshold=15
----

=== まとめ

Quarkus とは何か、また、最新のJava マイクロサービス指向アプリケーションを作成するためにどのように使用できるのかについて、少し詳しく学びました。

モノリシック CoolStore アプリケーションの以前に実装されていた機能を表す新しい在庫マイクロサービスを作成しました。今のところ、この新しいマイクロサービスはモノリスから完全に切り離されており、それだけではあまり役に立ちません。今後のステップでは、このマイクロサービスと他のマイクロサービスをモノリスにリンクして、 https://www.martinfowler.com/bliki/StranglerApplication.html[モノリスを抑制する^] プロセスを開始します。

次のラボでは、もう一つの人気フレームワークである Spring Boot を使って、追加のマイクロサービスを実装します。がんばりましょう！
