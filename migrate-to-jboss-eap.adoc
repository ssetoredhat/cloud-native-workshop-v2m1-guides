= Lab 2 - JBoss EAPにアプリケーションを移行する
:experimental:

このステップでは、アプリ内の Weblogic 固有のコードを移行して、標準（Jakarta EE）インターフェースを使用するようにします。

=== 1.開発環境へのアクセス

https://www.eclipse.org/che/[Eclipse Che^] をベースにしたオンライン IDE である Red Hat CodeReady Workspaces を使用していただきます。 *ファイルへの変更は数秒ごとに自動保存* されるので、明示的に変更を保存する必要はありません。

開始するには、 {{ ECLIPSE_CHE_URL }}[CodeReady Workspaces インスタンスにアクセス^] し、割り当てられたユーザー名とパスワード（例： `{{ USER_ID }}/{{ CHE_USER_PASSWORD }}`）を使用してログインします。

image::che-login.png[cdw, 700]

ログインすると、個人のダッシュボードが表示されます。左側の作成済みワークスペースの名前をクリックすると、以下のようになります（割り当てられた番号によって名前が異なります）。

image::crw-landing.png[cdw, 700]

また、中央のワークスペースの名前をクリックして、画面右上の _Open_ と書かれた緑色の {{ USER_ID}}-namespace をクリックします。

image::crw-landing-start.png[cdw, 700]

1～2分後、ワークスペースに配置されます。

image::che-workspace.png[cdw, 900]

この IDE は、Eclipse Cheをベースにしています（これは、同様にMicroSoft VS Code editorをベースにしています）。

左側には、プロジェクトエクスプローラ、検索、バージョン管理（Gitなど）、デバッグ、その他のプラグイン間を移動するためのアイコンが表示されています。このワークショップでは、これらを使用します。気軽にクリックしてみてください。

image::crw-icons.png[cdw, 400]

[NOTE]
====
おかしなことになったり、ブラウザに表れたりした場合、単にブラウザタブを再読み込みして表示を更新するだけです。
====

CodeReady Workspaces の多くの機能は、 *コマンド* を介してアクセスできます。ホームページでは、リンク付きのコマンドをいくつか見られます (例: _New File.._ 、 _Git Clone.._ 、その他)。

メニューに表示されていないコマンドを実行したい場合は、kbd:[F1] を押してコマンドウィンドウを開くか、従来の kbd:[Control+SHIFT+P] （Mac OS Xでは kbd:[Command+SHIFT+P] ）を押してコマンドを実行ができます。

最初のプロジェクトをインポートしてみましょう。 **Git Clone..** をクリックします。（または kbd:[F1] とするか、'git'と入力し自動で補完された _Git Clone.._ をクリックします）

image::che-workspace-gitclone.png[cdw, 900]

**リポジトリの URL** に次の値を使用して、プロンプトを進めます。 *FireFox* を使っていると、最後に余計なスペースを貼り付けてしまうことがあるので、貼り付けた後にバックスペースを押してください。

[source,none,role="copypaste"]
----
https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m1-labs.git
----

image::crw-clone-repo.png[crw,900]

プロジェクトはワークスペースにインポートされ、プロジェクト エクスプローラに表示されます。

image::crw-clone-explorer.png[crw,900]

==== 重要：適切な Git ブランチをチェック

プロジェクトファイルの正しいバージョンを使用していることを確認するには、CodeReady ターミナルでこのコマンドを実行してください。

[source,sh,role="copypaste"]
----
cd $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs && git checkout ocp-4.5
----

[NOTE]
====
CodeReady Workspacesのターミナルウィンドウ。開発者ワークスペースで実行されているコンテナのターミナル ウィンドウを開けます。これらのラボの残りの部分については、ターミナルでコマンドを実行する必要がある場合はいつでも、右側の **>_ New Terminal** コマンドを使用できます。
====

image::codeready-workspace-terminal.png[codeready-workspace-terminal, 700]


==== 2. `ApplicationLifecycleListener` の問題を修正

{{ MTA_URL }}[MTA Console^] で Issues レポートを開きます。

image::rhamt_project_issues.png[rhamt_project_issues, 700]

RHAMTは、課題をより深く理解し、移行のためのガイダンスを提供するための有用なリンクを提供しています。

[NOTE]
====
（訳注）ここで Issue の一覧にある `WebLogic ApplicationLifecycleEvent` を開いて下さい。そして、Issue の対象となるファイルと Issue の詳細を確認してから以下へお進み下さい。
====

WebLogic `ApplicationLifecycleListener` 抽象クラスは、機能を実行したり、サーバーの起動や停止など Oracle WebLogic でジョブをスケジュールしたりするために使用されます。今回の場合、 `postStart` メソッドと `preStop` メソッドがコードにあります。これらはWeblogic が起動した後とシャットダウンする前にそれぞれ実行されます。

Jakarta EEでは、これらのイベントを傍受することに相当するものはありません。しかし、RHAMTレポートの問題で提案されているように、標準的なアノテーションを持つ _Singleton EJB_ を使用して同等の機能を得られます。

`@Startup` アノテーションを使用して、アプリケーションの開始時にシングルトンセッション Bean を初期化するようにコンテナに指示します。同様に `@PostConstruct` と `@PreDestroy` アノテーションを使用して、アプリケーションのライフサイクルの開始時と終了時に呼び出すメソッドを指定しますが、独自のインターフェイスを使用せずに同じ結果を得られます。

このメソッドを使用することで、コードの移植性が格段に向上します。

==== 3.ApplicationLifecycleListener の問題を修正

まず、Monolith アプリケーションの問題を修正します。プロジェクトツリーの `cloud-native-workshop-v2m1-labs` フォルダに移動し、 `monolith/src/main/java/com/redhat/coolstore/utils/StartupListener.java` ファイルをクリックして開きます。

ファイルの内容を以下の様に置き換えます。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.utils;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.Startup;
import javax.inject.Singleton;
import javax.inject.Inject;
import java.util.logging.Logger;

@Singleton
@Startup
public class StartupListener {

    @Inject
    Logger log;

    @PostConstruct
    public void postStart() {
        log.info("AppListener(postStart)");
    }

    @PreDestroy
    public void preStop() {
        log.info("AppListener(preStop)");
    }

}
----

[NOTE]
====
保存ボタンはどこにありますか？CodeReadyワークスペースは変更内容を自動的に保存します。それがSAVEボタンが見つからない理由です。保存を忘れたためにコードを失うことはもうありません。元に戻すには kbd:[CTRL-Z] （Mac の場合は kbd:[CMD-Z] ）を使用するか、 `Edit （編集） -> Undo（元に戻す）` メニューオプションを使用します。
====


==== 4.ビルドのテスト

`quarkus-tools` コンテナの下にある新しいターミナルウィンドウを開きます（右側）。ターミナルで以下のコマンドを実行してビルドをテストします。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

image::codeready-workspace-build.png[rhamt_project_issues, 700]

ビルドが成功したら（ `BUILD SUCCESS` と表示されます）、次の課題に進みましょう！コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

image::codeready-workspace-build-result.png[rhamt_project_issues, 700]

===== 差分を見る

変更した内容を見直せます。左側の _Version Control_ （バージョン管理）アイコンをクリックすると、変更されたファイルの一覧が表示されます。 `StartupListener.java` をダブルクリックして、変更点を確認します。

image::codeready-workspace-diffs.png[diffs, 700]

CodeReady は、（Gitを使用して） 変更した内容を追跡し、バージョン管理を使用して、変更したファイルのチェックイン、更新、変更したファイルの比較を行えます。

とりあえず、 _Explorer_ ツリーに戻って、残っている問題を修正しましょう。

==== 5.ロガーの問題を修正

私たちのアプリケーションの中には、 `NonCatalogLogger` やクライアントサーバロギングのような Weblogic 固有のロギングメソッドを使用しているものがあります。NonCatalogLogger は国際化されたコンテンツのロギングに関連した機能を提供します。

WebLogic  `NonCatalogLogger` は、JBoss EAP (またはその他の Java EE プラットフォーム) ではサポートされていません。これは JDK Logger や JBoss Logging などのサポートされているロギングフレームワークに移行する必要があります。

移植性の高いフレームワークである標準的な Java Logging フレームワークを使用します。フレームワークも必要に応じて https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html#a1.17[国際化をサポートしています^]。

同じ `monolith` ディレクトリで、 `src/main/java/com/redhat/coolstore/service/OrderServiceMDB.java` ファイルを開き、その内容を次のように置き換えます。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.service;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

import com.redhat.coolstore.model.Order;
import com.redhat.coolstore.utils.Transformers;

import java.util.logging.Logger;

@MessageDriven(name = "OrderServiceMDB", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "topic/orders"),
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),
    @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge")})
public class OrderServiceMDB implements MessageListener {

    @Inject
    OrderService orderService;

    @Inject
    CatalogService catalogService;

    private Logger log = Logger.getLogger(OrderServiceMDB.class.getName());

    @Override
    public void onMessage(Message rcvMessage) {
        TextMessage msg = null;
        try {
                if (rcvMessage instanceof TextMessage) {
                        msg = (TextMessage) rcvMessage;
                        String orderStr = msg.getBody(String.class);
                        log.info("Received order: " + orderStr);
                        Order order = Transformers.jsonToOrder(orderStr);
                        log.info("Order object is " + order);
                        orderService.save(order);
                        order.getItemList().forEach(orderItem -> {
                            catalogService.updateInventoryItems(orderItem.getProductId(), orderItem.getQuantity());
                        });
                }
        } catch (JMSException e) {
            throw new RuntimeException(e);
        }
    }

}
----

これは簡単でした。

==== 6.ビルドのテスト

前と同じようにアプリをビルドしてパッケージ化し直します。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

ビルドが成功したら（ `BUILD SUCCESS` と表示されます）、次の課題に移りましょう！コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

==== MDB の問題を修正

この最後のステップでは、アプリ内の Weblogic 固有のコードを標準の Java EE インターフェイスと JBoss 固有のインターフェイスを使用するように再度移行します。

私たちのアプリケーションは https://ja.wikipedia.org/wiki/Java_Message_Service[JMS^] を使用して通信を行っています。アプリケーションで注文が入るたびに、JMS トピックに JMS メッセージが送信されます。これは、Java EE アプリケーションがメッセージを非同期的に処理できるようにする Enterprise JavaBeans (EJB) の一形態である https://docs.oracle.com/javaee/6/tutorial/doc/gipko.html[Message-driven beans^] を使用して注文を処理するために、そのトピックへのリスナー (サブスクライバ) によって消費されます。

この場合、 `InventoryNotificationMDB` は、 `ShoppingCartService` からのメッセージを購読し、リッスンしている。 `ShoppingCartService` を経由して注文が来ると、JMS トピックにメッセージが置かれます。その時点で、 `InventoryNotificationMDB` はメッセージを受信します。そして、インベントリサービスが事前に定義された閾値を下回っている場合、製品の供給者に通知する必要があることを示すメッセージをログに送信します。

残念ながら、この MDB は少し前に書かれたものです。これは、MDBを構成して操作するために、WebLogic 固有のインターフェースを利用しています。RHAMT はこれにフラグを立て、いくつかの課題を使用して報告しました。

JBoss EAP は、MDB のライフサイクルを設定して管理するための、より効率的で宣言的な方法を提供します。この場合、アノテーションを利用して、必要な初期化や設定のロジックや設定を行えます。Weblogicと同じ機能を提供するため `MessageListener` インターフェースに加えて、私たちは `@MessageDriven` と `@ActivationConfigProperty` アノテーションを使用するでしょう。

MDB のような EJB コンポーネントのための Weblogic のインターフェースの多くは、Weblogic の XML ディスクリプタファイルにあります。 `src/main/webapp/WEB-INF/weblogic-ejb-jar.xml` を開いて、これらのディスクリプタのいずれかを確認してください。このファイルには、EJB と MDB のための多くの異なる設定の可能性があります。しかし、幸いにも私たちのアプリケーションはそれらのうちの 1 つしか使用していません。すなわち、 `<trans-timeout-seconds>` を 30 に設定しています。これは、MDB 操作内のあるトランザクションが完了するのに時間がかかりすぎる（ 30 秒以上）ことを意味します。この時、トランザクションはロールバックされ、例外がスローされます。このインターフェイスは Weblogic 固有のものなので、JBoss で同等のものを見つける必要があります。

[NOTE]
====
このタイプの移行は、以前のステップよりも複雑であることを認識しておく必要があります。そして、実際のアプリケーションでは、移行のために一度に 1 行ずつ変更するような単純なことはほとんどありません。Red Hat のアプリケーション移行戦略の詳細については https://access.redhat.com/documentation/en/red-hat-application-migration-toolkit[RHAMT ドキュメント^] を参照するか、Red Hat がお客様の移行パスでどのように支援できるかについて、お近くの Red Hat の担当者にお問い合わせください。
====

==== 7.課題の見直し

RHAMTの課題レポートから、残っている課題を修正していきます。

* `JNDI ルックアップの呼び出し` - 私たちのアプリは Weblogic 固有の https://ja.wikipedia.org/wiki/Java_Naming_and_Directory_Interface[JNDI^] ルックアップスキームを使用
* `固有の InitialContext の初期化` - Weblogic は InitialContext オブジェクトのルックアップメカニズムが大きく異なる
* `WebLogic InitialContextFactory` - これは上記に関連しており、基本的には Weblogic 固有のメカニズム
* `WebLogic T3 JNDI バインディング` - EJB が Weblogic で通信する方法は、Weblogic 固有な実装であるT2を介する

上記のすべてのインターフェイスは、JBoss で同等のものを持っています。しかし、これらは非常に単純化されていて、私たちのアプリケーションには過剰なものです。これは https://activemq.apache.org/artemis/[Apache ActiveMQ Artemis^] によって提供される JBoss EAP の内部メッセージキュー実装を使用します。

==== 8.weblogic EJB ディスクリプタを削除

最初のステップは、不要な `weblogic-ejb-jar.xml` ファイルを削除することです。このファイルは Weblogic 固有であり、JBoss EAP によって認識または処理されることはありません。 `src/main/webapp/WEB-INF/weblogic-ejb-jar.xml` ファイルを右クリックして削除し、 **Delete** を選択して **OK** をクリックします。

image::codeready-workspace-delete-jar.png[codeready-workspace-convert, 500]

今のうちに、シナリオの一部として追加されたスタブの weblogic 実装クラスを削除しておきましょう。

`src/main/java/weblogic` フォルダを右クリックし、 *Delete* を選択してフォルダを削除します。

image::codeready-workspace-delete-weblogic.png[codeready-workspace-convert, 500]

==== 9.コードの修正


`monolith/src/main/java/com/redhat/coolstore/service/InventoryNotificationMDB.java` ファイルを開き、その内容を置き換えます。


[source,java, role="copypaste"]
----
package com.redhat.coolstore.service;

import com.redhat.coolstore.model.Order;
import com.redhat.coolstore.utils.Transformers;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;
import java.util.logging.Logger;

@MessageDriven(name = "InventoryNotificationMDB", activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "topic/orders"),
        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),
        @ActivationConfigProperty(propertyName = "transactionTimeout", propertyValue = "30"),
        @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge")})
public class InventoryNotificationMDB implements MessageListener {

    private static final int LOW_THRESHOLD = 50;

    @Inject
    private CatalogService catalogService;

    @Inject
    private Logger log;

    public void onMessage(Message rcvMessage) {
        TextMessage msg;
        {
            try {
                if (rcvMessage instanceof TextMessage) {
                    msg = (TextMessage) rcvMessage;
                    String orderStr = msg.getBody(String.class);
                    Order order = Transformers.jsonToOrder(orderStr);
                    order.getItemList().forEach(orderItem -> {
                        int old_quantity = catalogService.getCatalogItemById(orderItem.getProductId()).getInventory().getQuantity();
                        int new_quantity = old_quantity - orderItem.getQuantity();
                        if (new_quantity < LOW_THRESHOLD) {
                            log.warning("Inventory for item " + orderItem.getProductId() + " is below threshold (" + LOW_THRESHOLD + "), contact supplier!");
                        }
                    });
                }


            } catch (JMSException jmse) {
                System.err.println("An exception occurred: " + jmse.getMessage());
            }
        }
    }
}
----

`weblogic-ejb-jar.xml` ファイルの `<trans-timeout-seconds>` 設定を覚えていますか？これを新しいコードで `@ActivationConfigProperty` として設定するようになりました。アノテーションとXML記述子の使用には長所と短所があり、アプリケーションのニーズを考慮して注意を払う必要があります。 

これで、MDB は JBoss EAP に適切に移行されるはずです。

==== 10.ビルドのテスト

もう一度ビルドしてください。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

image::codeready-workspace-build.png[rhamt_project_issues, 700]

ビルドが成功した場合（ `BUILD SUCCESS` と表示されます）。コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

==== 11.RHAMTレポートの再実行

このステップでは、移行が成功したことを確認するためにRHAMTレポートを再実行します。

{{ MTA_URL }}[RHAMT Console^] で、左メニューの `Applications` に移動し、 *Add* をクリックします。 *Server Path* タブを開き、固定プロジェクトのパスを `/opt/solution` と入力し、 *Upload* をクリックしてプロジェクトを追加します。

image::rhamt_rerun_analysis_report_solution.png[rhamt_rerun_analysis_report, 700]

古い `monolith.war` を削除して、再度分析しないようにしてから、 *Save and Run* をクリックしてプロジェクトを分析してください。

image::rhamt_rerun_analysis_report_solution_del.png[rhamt_rerun_analysis_report, 700]

レポートを実行している他の受講者の数にもよりますが、あなたの分析は数分 _待ち_ になるかもしれません。時間がかかりすぎる場合は、次のセクションをスキップして、ステップ *13* に進み、後で分析に戻って、すべての問題を排除したことを確認してください。

==== 12.結果を確認

最新の結果をクリックしてレポートのWebページに移動し、現在はストーリーポイントが 0 を報告していることを確認してください。

このアプリを JBoss EAP に正常に移行しました。おめでとうございます！

image::rhamt_project_issues_story.png[rhamt_project_issues_story, 700]

アプリの移行が完了したので、デプロイしてテストし、JBoss EAP に加え Red Hat OpenShift がもたらす機能のいくつかを探ってみましょう。

==== 13.OpenShiftプロファイルの追加

'''''


`monolith/pom.xml` ファイルを開きます。


この `<!-- TODO: Add OpenShift profile here -\->` pom.xml に以下の設定を追加します。

[source,xml,role="copypaste"]
----
        <profile>
          <id>openshift</id>
          <build>
              <plugins>
                  <plugin>
                      <artifactId>maven-war-plugin</artifactId>
                      <version>2.6</version>
                      <configuration>
                          <webResources>
                              <resource>
                                  <directory>${basedir}/src/main/webapp/WEB-INF</directory>
                                  <filtering>true</filtering>
                                  <targetPath>WEB-INF</targetPath>
                              </resource>
                          </webResources>
                          <outputDirectory>${basedir}/deployments</outputDirectory>
                          <warName>ROOT</warName>
                      </configuration>
                  </plugin>
              </plugins>
          </build>
        </profile>
----

==== 14.OpenShiftプロジェクトの作成

まず、新規ブラウザで {{ CONSOLE_URL }}[OpenShift web コンソール^] を開きます。

image::openshift_login.png[openshift_login, 700]

資格情報を使ってログインします。

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

アクセスできるプロジェクトのリストが表示されます。

image::openshift_landing.png[openshift_landing, 700]

[NOTE]
====
最初に表示されるページに表示されるプロジェクトは、あなたが実行するラボによって異なります。
====

**Create Project** をクリックし、フィールドを入力して、 *Create* をクリックします。

* Name: `{{USER_ID }}-coolstore-dev`
* Display Name: `{{ USER_ID }} Coolstore Monolith - Dev`
* Description: _このフィールドは空にしてください_

[NOTE]
====
プロジェクト名として `{{ USER_ID }}-coolstore-dev` を使用しなければ *なりません* 。この名前は後に参照されるので、 `{{ USER_ID }}-coolstore-dev` と名前を付けないと失敗することになります！
====

image::create_dialog.png[create_dialog, 700]

これでプロジェクトの概要に移動します。まだ何もありませんが、それが変わろうとしています。

image::project_overview.png[create_new, 700]

==== 開発者視点への切り替え

OpenShift 4 では、コンソールに _Administrator_ ビューと _Developer_ ビューの両方を提供しています。左側のドロップダウンを使用して、 _Developer_ ビューに切り替えます。

image::dev_perspective.png[create_new, 700]

これにより、プロジェクトにデプロイされたアプリケーションの開発者中心のビューを提供します。まだ何もデプロイされていないので、アプリケーションをデプロイする方法が提示されています。

==== 15.モノリスの展開

使用するアプリケーション _テンプレート_ をあらかじめインストールしておきました。 *From Catalog* をクリックします。

image::from_catalog.png[create_new, 700]

検索ボックスに `coolstore` と入力し、 _Coolstore Monolith using binary build_ を選択し、 *Instantiate Template* をクリックします。 _coolstore_ のテンプレートが表示されない場合は、 _Type_ にある *Operator Backed* チェックを外してください。

image::from_catalog_bin.png[create_new, 700]

以下の項目を記入してください。

* *Namespace* : `{{USER_ID}}-coolstore-dev` (これは既に選択されているはずです)
* *User ID* : `{{ USER_ID }}`

image::from_catalog_bin_details.png[create_new, 700]

他の値はそのままにして、 **Create** をクリックします。

_Topology_ ビューに移動して、デプロイされた要素を確認します。

Web コンソールの _Developer_ ビューの *Topology* ビューでは、プロジェクト内のすべてのアプリケーション、そのビルドステータス、およびそれらに関連するコンポーネントとサービスを視覚的に表示します。

image::coolstore_topology.png[create_new, 700]

実行中の _postgres_ データベース（紺色の丸で囲んでいます）と、まだデプロイも起動もされていない coolstore モノリスを見ることができます。

==== モノリスを CLI を使ってデプロイ

Eclipse Che ワークスペースは Kubernetes クラスタ上で実行されています。これはデフォルトの制限付き _サービス アカウント_ で実行されているため、ほとんどのリソース タイプを作成することができません。他のモジュールを完了している場合は、すでにログインしていると思いますが、もう一度ログインしてみましょう： *Login to OpenShift* をクリックして、与えられた資格情報を入力します。

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

image::cmd-login.png[login,700]

このようなものが表示されるはずです（プロジェクト名が異なる場合があります）。

[source,none]
----
Login successful.

You have access to the following projects and can switch between them with 'oc project <projectname>':

  * {{ USER_ID }}-bookinfo
    {{ USER_ID }}-catalog
    {{ USER_ID }}-cloudnative-pipeline
    {{ USER_ID }}-cloudnativeapps
    {{ USER_ID }}-inventory
    {{ USER_ID }}-istio-system

Using project "{{ USER_ID }}-bookinfo".
Welcome! See 'oc help' to get started.
----

[NOTE]
====
*Login to OpenShift* してログインすると、そのターミナルは通常の端末としては使えなくなります。ターミナルウィンドウを閉じることができます。後からさらに端末を開いてもログインしたままになってしまいます
====

CodeReady Workspaces ターミナルウィンドウから先ほど作成した開発者プロジェクトに切り替えます。

[source,sh,role="copypaste"]
----
oc project {{ USER_ID }}-coolstore-dev
----

次に、CodeReady ターミナルでこのコマンドを実行して、コンポーネントに適切なアイコンが表示されるようにラベルを付けます。

[source,sh,role="copypaste"]
----
oc label dc/coolstore-postgresql app.openshift.io/runtime=postgresql --overwrite && \
oc label dc/coolstore app.openshift.io/runtime=jboss --overwrite && \
oc label dc/coolstore-postgresql app.kubernetes.io/part-of=coolstore --overwrite && \
oc label dc/coolstore app.kubernetes.io/part-of=coolstore --overwrite && \
oc annotate dc/coolstore app.openshift.io/connects-to=coolstore-postgresql --overwrite && \
oc annotate dc/coolstore app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m1-labs.git --overwrite && \
oc annotate dc/coolstore app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

image::coolstore-labels.png[create_new, 600]

前のステップで構築したコンテナイメージをまだデプロイしていませんが、次のステップでデプロイします。

==== 16.バイナリビルドを利用したアプリケーションのデプロイ

この開発プロジェクトでは、 _バイナリビルド_ と呼ばれるプロセスを使用することを選択しました。つまり、公開されている Git リポジトリを指す代わりに、S2I  (Source-to-Image) のビルドプロセスをダウンロードしてビルドします。そして、コンテナイメージを作成して、ローカルに構築し、成果物 （例えば `.war` ファイル）をアップロードするだけです。バイナリでのデプロイは、ビルドプロセスを大幅にスピードアップします。

まず、 `openshift` の Maven プロファイルを使用してプロジェクトをもう一度構築します。これは OpenShift で使用するのに適したバイナリを作成します（これはまだコンテナイメージではなく、 `.war` ファイルだけです）。 `oc` コマンドラインでこれを行います。

CodeReady Workspaces ターミナルウィンドウからプロジェクトをビルドします。

[source,sh,role="copypaste"]
----
mvn clean package -Popenshift -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith
----

ビルドが終了し、 `BUILD SUCCESS` のメッセージが表示されるのを待ちましょう

そして最後に、 `.war` ファイルを取得し、JBoss EAP と組み合わせて Linux コンテナイメージを生成するビルドプロセスを開始します。これは自動的にプロジェクトにデプロイされます。これはテンプレートから作成された _DeploymentConfig_ オブジェクトのおかげです。

[source,sh,role="copypaste"]
----
oc start-build coolstore --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith/deployments/ROOT.war
----

Topology ビューに戻ると、モノリスがビルドされているのが見えるはずです。

image::monolith_build.png[building]

ビルド中のアイコンをクリックすると、ビルドのログが表示されます。

image::monolith_log.png[building]

Topology ビューに戻り、メインアイコンをクリックして _Overview_ を表示します。

image::monolith_starting.png[building, 700]

デプロイが完了して紺色の丸が出てくるのを待ちます。

image::monolith_wait.png[building, 700]

Route リンクをクリックしてアプリケーションをテストします。


[NOTE]
====
（訳注）クラスタのリソースによっては起動にしばらく時間が掛かり、なかなか表示されないことがあります。
====


image::route_link.png[route_link, 400]

==== おめでとうございます！

これで、OpenShift 上でローカルに構築したものと同じアプリケーションを使用していることになります。難しくなかったのではないでしょうか？

image::coolstore_web.png[coolstore_web, 700]

==== まとめ

これで、既存のJava EEアプリをJBossとOpenShiftでクラウドに移行できました。モノリスを段階的に小さなマイクロサービスに分解することで、アプリケーションの近代化を始める準備ができました。これは、アプリケーションが分散およびコンテナ化された環境で正常に動作することを保証するために、最新の技術を採用しています。