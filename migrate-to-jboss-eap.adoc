:imagesdir: images

= Lab 2 - JBoss EAPにアプリケーションを移行する
:experimental:

このステップでは、アプリ内の Weblogic 固有のコードを移行して、標準（Jakarta EE）インターフェースを使用するようにします。

=== 1. コードへジャンプ

特定された移行問題を含むコードにジャンプしてみましょう。MTAエクスプローラで *monolith* ソースプロジェクトを展開します。そして `monolith > src > main > java > com > redhat > coolstore > utils > StartupListener.java` へ移動します。実際のクラス名 `StartupListener.java` の横にある矢印をクリックすると、ヒントが展開されて表示されます。

image::mta_project_issues.png[mta, 500]

エクスプローラでは、MTAが発見した課題が深刻度レベルとステータスを示すアイコンで示されています。次の表では、さまざまなアイコンの意味を説明します。

image::mta-issues-table.png[mta, 700]

=== 2. マイグレーションの課題の詳細を確認

マイグレーションの課題の詳細を見てみましょう。 _StartupListener.java_ ファイルの _Hints_ 内の `WebLogic ApplicationLifecycleListenerEvent[rule-id:xxx]` を右クリックします。 `View Details` をクリックします。

image::mta-issue-detail.png[rhamt_project_issues, 900]

MTAはまた、`Open Report` をクリックすると、問題をより深く理解し、移行のためのガイダンスを提供するための有用なリンクを提供しています。

image::mta-issue-open-report.png[rhamt_project_issues, 900]


WebLogic `ApplicationLifecycleListener` 抽象クラスは、機能を実行したり、サーバーの起動や停止など Oracle WebLogic でジョブをスケジュールしたりするために使用されます。今回の場合、 `postStart` メソッドと `preStop` メソッドがコードにあります。これらはWeblogic が起動した後とシャットダウンする前にそれぞれ実行されます。

Jakarta EEでは、これらのイベントを傍受することに相当するものはありません。しかし、MTAレポートの問題で提案されているように、標準的なアノテーションを持つ _Singleton EJB_ を使用して同等の機能を得られます。

`@Startup` アノテーションを使用して、アプリケーションの開始時にシングルトンセッション Bean を初期化するようにコンテナに指示します。同様に `@PostConstruct` と `@PreDestroy` アノテーションを使用して、アプリケーションのライフサイクルの開始時と終了時に呼び出すメソッドを指定しますが、独自のインターフェイスを使用せずに同じ結果を得られます。

このメソッドを使用することで、コードの移植性が格段に向上します。

=== 3.ApplicationLifecycleListener の問題を修正

まず、Monolith アプリケーションの問題を修正します。
_StartupListener.java_ ファイルの _Hints_ 内の `WebLogic ApplicationLifecycleListenerEvent[rule-id:xxx]` を右クリックします。`Open Code` をクリックします。

image::mta-issue-open-code.png[rhamt_project_issues, 900]

プロジェクトツリーの `cloud-native-workshop-v2m1-lab` フォルダに移動し、ファイル `monolith/src/main/java/com/redhat/coolstore/utils/StartupListener.java` をクリックして開くこともできます。

ファイルの内容を以下の様に置き換えます。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.utils;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.Startup;
import javax.inject.Singleton;
import javax.inject.Inject;
import java.util.logging.Logger;

@Singleton
@Startup
public class StartupListener {

    @Inject
    Logger log;

    @PostConstruct
    public void postStart() {
        log.info("AppListener(postStart)");
    }

    @PreDestroy
    public void preStop() {
        log.info("AppListener(preStop)");
    }

}
----

[NOTE]
====
保存ボタンはどこにありますか？CodeReadyワークスペースは変更内容を自動的に保存します。それがSAVEボタンが見つからない理由です。保存を忘れたためにコードを失うことはもうありません。元に戻すには kbd:[CTRL-Z] （Mac の場合は kbd:[CMD-Z] ）を使用するか、 `Edit （編集） -> Undo（元に戻す）` メニューオプションを使用します。
====


=== 4.ビルドのテスト

`quarkus-tools` コンテナの下にある新しいターミナルウィンドウを開きます（右側）。ターミナルで以下のコマンドを実行してビルドをテストします。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

image::codeready-workspace-build.png[rhamt_project_issues, 700]

ビルドが成功したら（ `BUILD SUCCESS` と表示されます）、次の課題に進みましょう！コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

image::codeready-workspace-build-result.png[rhamt_project_issues, 700]

==== 差分を見る

変更した内容を見直せます。左側の _Version Control_ （バージョン管理）アイコンをクリックすると、変更されたファイルの一覧が表示されます。 `StartupListener.java` をダブルクリックして、変更点を確認します。

image::codeready-workspace-diffs.png[diffs, 700]

CodeReady は、（Gitを使用して） 変更した内容を追跡し、バージョン管理を使用して、変更したファイルのチェックイン、更新、変更したファイルの比較を行えます。

とりあえず、 _Explorer_ ツリーに戻って、残っている問題を修正しましょう。

=== 5.ロガーの問題を修正

私たちのアプリケーションの中には、 `NonCatalogLogger` やクライアントサーバロギングのような Weblogic 固有のロギングメソッドを使用しているものがあります。NonCatalogLogger は国際化されたコンテンツのロギングに関連した機能を提供します。

WebLogic  `NonCatalogLogger` は、JBoss EAP (またはその他の Java EE プラットフォーム) ではサポートされていません。これは JDK Logger や JBoss Logging などのサポートされているロギングフレームワークに移行する必要があります。

移植性の高いフレームワークである標準的な Java Logging フレームワークを使用します。フレームワークも必要に応じて https://docs.oracle.com/javase/8/docs/technotes/guides/logging/overview.html#a1.17[国際化をサポートしています^]。

同じ `monolith` ディレクトリで、 `src/main/java/com/redhat/coolstore/service/OrderServiceMDB.java` ファイルを開き、その内容を次のように置き換えます。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.service;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

import com.redhat.coolstore.model.Order;
import com.redhat.coolstore.utils.Transformers;

import java.util.logging.Logger;

@MessageDriven(name = "OrderServiceMDB", activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "topic/orders"),
    @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),
    @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge")})
public class OrderServiceMDB implements MessageListener {

    @Inject
    OrderService orderService;

    @Inject
    CatalogService catalogService;

    private Logger log = Logger.getLogger(OrderServiceMDB.class.getName());

    @Override
    public void onMessage(Message rcvMessage) {
        TextMessage msg = null;
        try {
                if (rcvMessage instanceof TextMessage) {
                        msg = (TextMessage) rcvMessage;
                        String orderStr = msg.getBody(String.class);
                        log.info("Received order: " + orderStr);
                        Order order = Transformers.jsonToOrder(orderStr);
                        log.info("Order object is " + order);
                        orderService.save(order);
                        order.getItemList().forEach(orderItem -> {
                            catalogService.updateInventoryItems(orderItem.getProductId(), orderItem.getQuantity());
                        });
                }
        } catch (JMSException e) {
            throw new RuntimeException(e);
        }
    }

}
----

これは簡単でした。

=== 6.ビルドのテスト

前と同じようにアプリをビルドしてパッケージ化し直します。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

ビルドが成功したら（ `BUILD SUCCESS` と表示されます）、次の課題に移りましょう！コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

==== MDB の問題を修正

この最後のステップでは、アプリ内の Weblogic 固有のコードを標準の Java EE インターフェイスと JBoss 固有のインターフェイスを使用するように再度移行します。

私たちのアプリケーションは https://ja.wikipedia.org/wiki/Java_Message_Service[JMS^] を使用して通信を行っています。アプリケーションで注文が入るたびに、JMS トピックに JMS メッセージが送信されます。これは、Java EE アプリケーションがメッセージを非同期的に処理できるようにする Enterprise JavaBeans (EJB) の一形態である https://docs.oracle.com/javaee/6/tutorial/doc/gipko.html[Message-driven beans^] を使用して注文を処理するために、そのトピックへのリスナー (サブスクライバ) によって消費されます。

この場合、 `InventoryNotificationMDB` は、 `ShoppingCartService` からのメッセージを購読し、リッスンしている。 `ShoppingCartService` を経由して注文が来ると、JMS トピックにメッセージが置かれます。その時点で、 `InventoryNotificationMDB` はメッセージを受信します。そして、インベントリサービスが事前に定義された閾値を下回っている場合、製品の供給者に通知する必要があることを示すメッセージをログに送信します。

残念ながら、この MDB は少し前に書かれたものです。これは、MDBを構成して操作するために、WebLogic 固有のインターフェースを利用しています。
MTA はこれにフラグを立て、いくつかの課題を使用して報告しました。

JBoss EAP は、MDB のライフサイクルを設定して管理するための、より効率的で宣言的な方法を提供します。この場合、アノテーションを利用して、必要な初期化や設定のロジックや設定を行えます。Weblogicと同じ機能を提供するため `MessageListener` インターフェースに加えて、私たちは `@MessageDriven` と `@ActivationConfigProperty` アノテーションを使用するでしょう。

MDB のような EJB コンポーネントのための Weblogic のインターフェースの多くは、Weblogic の XML ディスクリプタファイルにあります。 `src/main/webapp/WEB-INF/weblogic-ejb-jar.xml` を開いて、これらのディスクリプタのいずれかを確認してください。このファイルには、EJB と MDB のための多くの異なる設定の可能性があります。しかし、幸いにも私たちのアプリケーションはそれらのうちの 1 つしか使用していません。すなわち、 `<trans-timeout-seconds>` を 30 に設定しています。これは、MDB 操作内のあるトランザクションが完了するのに時間がかかりすぎる（ 30 秒以上）ことを意味します。この時、トランザクションはロールバックされ、例外がスローされます。このインターフェイスは Weblogic 固有のものなので、JBoss で同等のものを見つける必要があります。

[NOTE]
====
このタイプの移行は、以前のステップよりも複雑であることを認識しておく必要があります。そして、実際のアプリケーションでは、移行のために一度に 1 行ずつ変更するような単純なことはほとんどありません。Red Hat のアプリケーション移行戦略の詳細については https://access.redhat.com/documentation/en-us/migration_toolkit_for_applications/[MTA documentation^] を参照するか、Red Hat がお客様の移行パスでどのように支援できるかについて、お近くの Red Hat の担当者にお問い合わせください。
====

=== 7.課題の見直し

MTAの課題レポートから、残っている課題を修正していきます。

* `JNDI ルックアップの呼び出し` - 私たちのアプリは Weblogic 固有の https://ja.wikipedia.org/wiki/Java_Naming_and_Directory_Interface[JNDI^] ルックアップスキームを使用
* `固有の InitialContext の初期化` - Weblogic は InitialContext オブジェクトのルックアップメカニズムが大きく異なる
* `WebLogic InitialContextFactory` - これは上記に関連しており、基本的には Weblogic 固有のメカニズム
* `WebLogic T3 JNDI バインディング` - EJB が Weblogic で通信する方法は、Weblogic 固有な実装であるT2を介する

上記のすべてのインターフェイスは、JBoss で同等のものを持っています。しかし、これらは非常に単純化されていて、私たちのアプリケーションには過剰なものです。これは https://activemq.apache.org/artemis/[Apache ActiveMQ Artemis^] によって提供される JBoss EAP の内部メッセージキュー実装を使用します。

=== 8. weblogic EJB ディスクリプタを削除

最初のステップは、不要な `weblogic-ejb-jar.xml` ファイルを削除することです。このファイルは Weblogic 固有であり、JBoss EAP によって認識または処理されることはありません。 `src/main/webapp/WEB-INF/weblogic-ejb-jar.xml` ファイルを右クリックして削除し、 **Delete** を選択して **OK** をクリックします。

image::codeready-workspace-delete-jar.png[codeready-workspace-convert, 500]

今のうちに、シナリオの一部として追加されたスタブの weblogic 実装クラスを削除しておきましょう。

`src/main/java/weblogic` フォルダを右クリックし、 *Delete* を選択してフォルダを削除します。

image::codeready-workspace-delete-weblogic.png[codeready-workspace-convert, 500]

=== 9.コードの修正

`monolith/src/main/java/com/redhat/coolstore/service/InventoryNotificationMDB.java` ファイルを開き、その内容を置き換えます。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.service;

import com.redhat.coolstore.model.Order;
import com.redhat.coolstore.utils.Transformers;

import javax.ejb.ActivationConfigProperty;
import javax.ejb.MessageDriven;
import javax.inject.Inject;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;
import java.util.logging.Logger;

@MessageDriven(name = "InventoryNotificationMDB", activationConfig = {
        @ActivationConfigProperty(propertyName = "destinationLookup", propertyValue = "topic/orders"),
        @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Topic"),
        @ActivationConfigProperty(propertyName = "transactionTimeout", propertyValue = "30"),
        @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge")})
public class InventoryNotificationMDB implements MessageListener {

    private static final int LOW_THRESHOLD = 50;

    @Inject
    private CatalogService catalogService;

    @Inject
    private Logger log;

    public void onMessage(Message rcvMessage) {
        TextMessage msg;
        {
            try {
                if (rcvMessage instanceof TextMessage) {
                    msg = (TextMessage) rcvMessage;
                    String orderStr = msg.getBody(String.class);
                    Order order = Transformers.jsonToOrder(orderStr);
                    order.getItemList().forEach(orderItem -> {
                        int old_quantity = catalogService.getCatalogItemById(orderItem.getProductId()).getInventory().getQuantity();
                        int new_quantity = old_quantity - orderItem.getQuantity();
                        if (new_quantity < LOW_THRESHOLD) {
                            log.warning("Inventory for item " + orderItem.getProductId() + " is below threshold (" + LOW_THRESHOLD + "), contact supplier!");
                        }
                    });
                }


            } catch (JMSException jmse) {
                System.err.println("An exception occurred: " + jmse.getMessage());
            }
        }
    }
}
----

`weblogic-ejb-jar.xml` ファイルの `<trans-timeout-seconds>` 設定を覚えていますか？これを新しいコードで `@ActivationConfigProperty` として設定するようになりました。アノテーションとXML記述子の使用には長所と短所があり、アプリケーションのニーズを考慮して注意を払う必要があります。 

これで、MDB は JBoss EAP に適切に移行されるはずです。

最後に、 *org.jboss.spec.javax.rmi:jboss-rmi-api_1.0_spec* へのMaven依存を削除します。JBoss EAP 7.3(またはそれ以降)では、groupId _org.jboss.spec.javax.rmi_ と artifactId _jboss-rmi-api_1.0_spec_ を持つアーティファクトはサポートされていない依存関係です。 `pom.xml` 内の以下の依存関係を削除してください。

image::mta-remove-dependency.png[rhamt_rerun_analysis_report, 700]

=== 10.ビルドのテスト

もう一度ビルドしてください。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith clean package
----

image::codeready-workspace-build.png[rhamt_project_issues, 700]

ビルドが成功した場合（ `BUILD SUCCESS` と表示されます）。コンパイルできない場合は、すべての変更が正しく行われていることを確認し、再度ビルドを試してください。

=== 11. MTAレポートの再実行

このステップでは、移行が成功したことを確認するためにMTAレポートを再実行します。

MTA エクスプローラで *mtaConfiguration* を右クリックして WebLogic アプリケーションを再度分析します。ポップアップメニューの `Run` をクリックします。

image::mta-rerun-report.png[rhamt_rerun_analysis_report, 700]

Migration Toolkit for Applications (MTA) CLIは新しいターミナルで自動的に実行され、分析を完了するには数分かかります。 `Open Report` をクリックします。

image::mta-analysis-rerun-complete.png[MTA Add App, 700]

[NOTE]
====
時間がかかりすぎる場合は、次のセクションをスキップして、ステップ *13* に進み、後で分析に戻って、すべての問題が解消されたことを確認してください。
====

=== 12.結果を確認

最新の結果をクリックしてレポートのWebページに移動し、現在はストーリーポイントが 0 を報告していることを確認してください。

このアプリを JBoss EAP に正常に移行しました。おめでとうございます！

image::rhamt_project_issues_story.png[rhamt_project_issues_story, 700]

アプリの移行が完了したので、デプロイしてテストし、JBoss EAP に加え Red Hat OpenShift がもたらす機能のいくつかを探ってみましょう。

=== 13.OpenShiftプロファイルの追加


`monolith/pom.xml` ファイルを開きます。


この `<!-- TODO: Add OpenShift profile here -\->` pom.xml に以下の設定を追加します。

[source,xml,role="copypaste"]
----
        <profile>
          <id>openshift</id>
          <build>
              <plugins>
                  <plugin>
                      <artifactId>maven-war-plugin</artifactId>
                      <version>2.6</version>
                      <configuration>
                          <webResources>
                              <resource>
                                  <directory>${basedir}/src/main/webapp/WEB-INF</directory>
                                  <filtering>true</filtering>
                                  <targetPath>WEB-INF</targetPath>
                              </resource>
                          </webResources>
                          <outputDirectory>${basedir}/deployments</outputDirectory>
                          <warName>ROOT</warName>
                      </configuration>
                  </plugin>
              </plugins>
          </build>
        </profile>
----

=== 14.OpenShiftプロジェクトの作成

まず、新規ブラウザで {{ CONSOLE_URL }}[OpenShift web コンソール^] を開きます。

image::openshift_login.png[openshift_login, 700]

資格情報を使ってログインします。

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

アクセスできるプロジェクトのリストが表示されます。

image::openshift_landing.png[openshift_landing, 700]

[NOTE]
====
最初に表示されるページに表示されるプロジェクトは、あなたが実行するラボによって異なります。
====

**Create Project** をクリックし、フィールドを入力して、 *Create* をクリックします。

* Name: `{{USER_ID }}-coolstore-dev`
* Display Name: `{{ USER_ID }} Coolstore Monolith - Dev`
* Description: _このフィールドは空にしてください_

[NOTE]
====
プロジェクト名として `{{ USER_ID }}-coolstore-dev` を使用しなければ *なりません* 。この名前は後に参照されるので、 `{{ USER_ID }}-coolstore-dev` と名前を付けないと失敗することになります！
====

image::create_dialog.png[create_dialog, 700]

これでプロジェクトの概要に移動します。まだ何もありませんが、それが変わろうとしています。

image::project_overview.png[create_new, 700]

==== 開発者視点への切り替え

OpenShift 4 では、コンソールに _Administrator_ ビューと _Developer_ ビューの両方を提供しています。左側のドロップダウンを使用して、 _Developer_ ビューに切り替えます。

image::dev_perspective.png[create_new, 700]

これにより、プロジェクトにデプロイされたアプリケーションの開発者中心のビューを提供します。まだ何もデプロイされていないので、アプリケーションをデプロイする方法が提示されています。

=== 15.モノリスのデプロイ

使用するアプリケーション _テンプレート_ をあらかじめインストールしておきました。 *From Catalog* をクリックします。

image::from_catalog.png[create_new, 700]

検索ボックスに `coolstore` と入力し、 _Coolstore Monolith using binary build_ を選択し、 *Instantiate Template* をクリックします。 _coolstore_ のテンプレートが表示されない場合は、 _Type_ にある *Operator Backed* チェックを外してください。

image::from_catalog_bin.png[create_new, 700]

以下の項目を記入してください。

* *Namespace*: `{{USER_ID}}-coolstore-dev` (これは既に選択されているはずです)
* *User ID*: `{{ USER_ID }}`

image::from_catalog_bin_details.png[create_new, 700]

他の値はそのままにして、 **Create** をクリックします。

_Topology_ ビューに移動して、デプロイされた要素を確認します。

Web コンソールの _Developer_ ビューの *Topology* ビューでは、プロジェクト内のすべてのアプリケーション、そのビルドステータス、およびそれらに関連するコンポーネントとサービスを視覚的に表示します。

image::coolstore_topology.png[create_new, 700]

実行中の _postgres_ データベース（紺色の丸で囲んでいます）と、まだデプロイも起動もされていない coolstore モノリスを見ることができます。

==== モノリスを CLI を使ってデプロイ

Eclipse Che ワークスペースは Kubernetes クラスタ上で実行されています。これはデフォルトの制限付き _サービス アカウント_ で実行されているため、ほとんどのリソース タイプを作成することができません。他のモジュールを完了している場合は、すでにログインしていると思いますが、もう一度ログインしてみましょう： *Login to OpenShift* をクリックして、与えられた資格情報を入力します。

* Username: `{{ USER_ID }}`
* Password: `{{ OPENSHIFT_USER_PASSWORD }}`

image::cmd-login.png[login,700]

このようなものが表示されるはずです（プロジェクト名が異なる場合があります）。

[source,none]
----
Login successful.

You have access to the following projects and can switch between them with 'oc project <projectname>':

  * {{ USER_ID }}-bookinfo
    {{ USER_ID }}-catalog
    {{ USER_ID }}-cloudnative-pipeline
    {{ USER_ID }}-cloudnativeapps
    {{ USER_ID }}-inventory
    {{ USER_ID }}-istio-system

Using project "{{ USER_ID }}-bookinfo".
Welcome! See 'oc help' to get started.
----

[NOTE]
====
*Login to OpenShift* してログインすると、そのターミナルは通常の端末としては使えなくなります。ターミナルウィンドウを閉じることができます。後からさらに端末を開いてもログインしたままになってしまいます
====

CodeReady Workspaces ターミナルウィンドウから先ほど作成した開発者プロジェクトに切り替えます。

[source,sh,role="copypaste"]
----
oc project {{ USER_ID }}-coolstore-dev
----

次に、CodeReady ターミナルでこのコマンドを実行して、コンポーネントに適切なアイコンが表示されるようにラベルを付けます。

[source,sh,role="copypaste"]
----
oc label dc/coolstore-postgresql app.openshift.io/runtime=postgresql --overwrite && \
oc label dc/coolstore app.openshift.io/runtime=jboss --overwrite && \
oc label dc/coolstore-postgresql app.kubernetes.io/part-of=coolstore --overwrite && \
oc label dc/coolstore app.kubernetes.io/part-of=coolstore --overwrite && \
oc annotate dc/coolstore app.openshift.io/connects-to=coolstore-postgresql --overwrite && \
oc annotate dc/coolstore app.openshift.io/vcs-uri=https://github.com/RedHat-Middleware-Workshops/cloud-native-workshop-v2m1-labs.git --overwrite && \
oc annotate dc/coolstore app.openshift.io/vcs-ref=ocp-4.5 --overwrite
----

image::coolstore-labels.png[create_new, 600]

前のステップで構築したコンテナイメージをまだデプロイしていませんが、次のステップでデプロイします。

=== 16.バイナリビルドを利用したアプリケーションのデプロイ

この開発プロジェクトでは、 _バイナリビルド_ と呼ばれるプロセスを使用することを選択しました。つまり、公開されている Git リポジトリを指す代わりに、S2I  (Source-to-Image) のビルドプロセスをダウンロードしてビルドします。そして、コンテナイメージを作成して、ローカルに構築し、成果物 （例えば `.war` ファイル）をアップロードするだけです。バイナリでのデプロイは、ビルドプロセスを大幅にスピードアップします。

まず、 `openshift` の Maven プロファイルを使用してプロジェクトをもう一度構築します。これは OpenShift で使用するのに適したバイナリを作成します（これはまだコンテナイメージではなく、 `.war` ファイルだけです）。 `oc` コマンドラインでこれを行います。

CodeReady Workspaces ターミナルウィンドウからプロジェクトをビルドします。

[source,sh,role="copypaste"]
----
mvn clean package -Popenshift -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith
----

ビルドが終了し、 `BUILD SUCCESS` のメッセージが表示されるのを待ちましょう

そして最後に、 `.war` ファイルを取得し、JBoss EAP と組み合わせて Linux コンテナイメージを生成するビルドプロセスを開始します。これは自動的にプロジェクトにデプロイされます。これはテンプレートから作成された _DeploymentConfig_ オブジェクトのおかげです。

[source,sh,role="copypaste"]
----
oc start-build coolstore --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith/deployments/ROOT.war
----

Topology ビューに戻ると、モノリスがビルドされているのが見えるはずです。

image::monolith_build.png[building]

ビルド中のアイコンをクリックすると、ビルドのログが表示されます。

image::monolith_log.png[building]

Topology ビューに戻り、メインアイコンをクリックして _Overview_ を表示します。

image::monolith_starting.png[building, 700]

デプロイが完了して紺色の丸が出てくるのを待ちます。

image::monolith_wait.png[building, 700]

Route リンクをクリックしてアプリケーションをテストします。


[NOTE]
====
（訳注）クラスタのリソースによっては起動にしばらく時間が掛かり、なかなか表示されないことがあります。
====


image::route_link.png[route_link, 400]

==== おめでとうございます！

これで、OpenShift 上でローカルに構築したものと同じアプリケーションを使用していることになります。難しくなかったのではないでしょうか？

image::coolstore_web.png[coolstore_web, 700]

==== まとめ

これで、既存のJava EEアプリをJBossとOpenShiftでクラウドに移行できました。モノリスを段階的に小さなマイクロサービスに分解することで、アプリケーションの近代化を始める準備ができました。これは、アプリケーションが分散およびコンテナ化された環境で正常に動作することを保証するために、最新の技術を採用しています。