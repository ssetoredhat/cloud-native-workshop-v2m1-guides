= Lab4 - モノリスをバラバラにする - II
:experimental:

前のラボでは、既存のモノリシックアプリを使用して、Quarkus を使用して単一の _在庫サービス_ をリファクタリングする方法を学びました。前のラボでは在庫サービスを作っていましたが、今のところモノリスを _抑圧し_ 始めたわけではありません。それは、在庫サービスが UI から直接呼び出されることがないからです。他のバックエンドサービスでしか使われていないものです。このラボでは、カタログサービスを作成し、カタログサービスが在庫サービスを呼び出します。準備ができたら、UI コールを新サービスに紐付けるルートを変更します。

これを実装するために、 https://access.redhat.com/products/spring-boot[Red Hat support for Spring Boot^] を利用します。このサービスに Spring を使う理由は、Spring Boot 開発の紹介と、 https://www.redhat.com/en/products/runtimes[Red Hat Runtimes^] がどのように Kubernetes 上での Spring 開発を簡単にするのに役立っているのかを紹介するためです。実際の生活の中で、Spring Boot を選ぶ理由は、ほとんどが既存の知識などの個人的な好みによるものです。核心部分では、Spring とJava EE は非常に似ています。

今回のゴールは以下のようなものを作ることです。

image::catalog-goal.png[Greeting, 700]

=== Spring Framework とは何ですか？

Spring は最も人気のあるJavaフレームワークの1つであり、Java EEプログラミングモデルに代わるものを提供しています。また、Spring はマイクロサービスアーキテクチャをベースにしたアプリケーションの構築にも人気があります。Spring Boot は Spring エコシステムで人気のあるツールで、Spring と一緒にサードパーティのライブラリを整理して利用するのに役立ちます。また、Apache Tomcat のような埋め込み可能なランタイムをブートストラップするメカニズムも提供しています。起動可能なアプリケーション（ _fat jar_ と呼ばれることもあります）はコンテナモデルに非常によく適合します。OpenShiftのようなコンテナプラットフォームでは、アプリケーションの起動、停止、監視などの責任はアプリケーションサーバーの代わりにコンテナプラットフォームで処理されるからです。

*Red Hat& は、 _Spring Boot_ の主要バージョンのサポートとメンテナンスを、定められた期間にわたって提供しています。 https://access.redhat.com/documentation/en-us/red_hat_support_for_spring_boot[さらに学ぶ^]。

=== マイクロサービスの呼び出しを集約します。

このラボで学ぶもう 1 つのことは、サービス間の呼び出しを利用してサービスを集約する技術の一つです。他に考えられる解決策としては、マイクロサービスゲートウェイを使用したり、クライアント側のロジックを使用してサービスを組み合わせることが考えられます。

==== 1.カタログプロジェクトのセットアップ

以下のコマンドを実行して、このラボの環境をセットアップし、正しいディレクトリで起動します。

プロジェクトエクスプローラで、 _catalog_ プロジェクトを展開します（いくつかのファイルの赤いエラーアイコンは無視してください。それは後ほど）

image::catalog-project.png[catalog-setup, 700]

==== 2.Mavenプロジェクトの構造を調べる

サンプルプロジェクトは、基本的な Spring Boot プロジェクトのコンポーネントを Maven のベストプラクティスに従って異なるサブディレクトリにレイアウトしています。

ご覧の通り、今回のプロジェクトでご用意したファイルがあります。 _src/main/resources/static/index.html_ の下に、例えば、html ベースのシンプルな UI ファイルを用意しました。これは https://start.spring.io[Spring Initializr^] ウェブページから空のプロジェクトを生成した場合と非常によく一致します。

若干異なるファイルとしては、 `pom.xml` があります。開いて、もう少し近くで吟味してみてください（ただし、このときは何も変えないでください）

内容を見直していくと、 _TODO_ コメントが多いことに気づきます。*絶対にコメントアウトしてはいけません！*これらのコメントはマーカーとして使用され、これがないとこのラボを終えることができません。

Spring Boot プロジェクトが通常使用するデフォルトのBOM（部品表）を使用していないことに注意してください。代わりに、 http://snowdrop.me/[Snowdrop^] プロジェクトの一部として Red Hat が提供している BOM を使用しています。

[source,xml]
----
<dependency>
    <groupId>dev.snowdrop</groupId>
    <artifactId>snowdrop-dependencies</artifactId>
    <version>2.2.6.Final-redhat-00001</version>
    <type>pom</type>
    <scope>import</scope>
</dependency>
----

Red Hat がサポートする Apache Tomcat などのバージョンを使用していることを確認するために、この BOM を使用しています。

==== 3.アプリケーションに Web （Apache Tomcat） を追加

私たちのアプリケーションはウェブアプリケーションになるので、Apache Tomcat や Undertow のようなサーブレットコンテナを使う必要があります。Red HatがApache Tomcatのサポート（セキュリティパッチやバグフィックスなど）を提供しているので、それを利用します。

[NOTE]
====
Undertow は Red Hat によってメンテナンスされているもう 1 つのオープンソースプロジェクトであり、Red Hat は近日中に Undertow のサポートを追加する予定です。
====

Red Hat の BOM と Red Hat の maven リポジトリへのアクセスのため、サポートされているサーブレットコンテナとしての Apache Tomcat を有効にする必要があります。それは、次の依存関係を _pom.xml_ に追加することです !-- TODO: Add web (tomcat) dependency here -->` のマーカーがある位置に以下を追加します。

[source,xml, role="copypaste"]
----
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
----

また、Java Persistence API（JPA）も利用します。そのため _pom.xml_ の `<!-- TODO: Add jdbc dependency here -->` に以下を追加します。

[source,xml, role="copypaste"]
----
        <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-jdbc</artifactId>
        </dependency>
----

先に行きましょう。pom.xmlを開いている間に他の依存関係の束を追加します。これらについては後ほど説明します。 `<!-- TODO: Add actuator, feign and hystrix dependency here -->` の場所へ以下を追加します。

[source,xml, role="copypaste"]
----
       <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>

        <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>

        <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>

        <dependency>
          <groupId>org.springframework.cloud</groupId>
          <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </dependency>
----

これで、赤いエラーアイコンも消えるはずです！さて、プロジェクトをビルドして、これまでのところすべてがコンパイルされていることを確認してください。

[source,sh,role="copypaste"]
----
mvn -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog clean package
----

ビルドが成功すれば（ *BUILD SUCCESS* と表示されます）、このラボの最初のステップが正常に実行されたことになります。

これでRed Hat Runtimes 上で Spring Boot 開発を始める方法がわかりました。

このラボの次のステップでは、データベースからデータを読み込めるようにするためのロジックを追加します。

==== 4.ドメインオブジェクトの作成

私たちは今、データベースリポジトリを実装する準備が整いました。

カタログプロジェクトで、 `src/main/java/com/redhat/coolstore/service` ディレクトリを右クリックし、**New File** を選択します。ファイル名は `ProductRepository.java` です。

image::newfile.png[catalog-setup, 700]

image::newfile-name.png[catalog-setup, 600]

ファイルに、このコードを追加します。

[source,java, role="copypaste"]
----
package com.redhat.coolstore.service;

import java.util.List;

import com.redhat.coolstore.model.Product;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

@Repository
public class ProductRepository {

    //TODO: Autowire the jdbcTemplate here

    //TODO: Add row mapper here

    //TODO: Create a method for returning all products

    //TODO: Create a method for returning one product

}
----

[NOTE]
====
このクラスには `@Repository` がアノテーションされています。これはスプリングの特徴であり、ボイラープレートのコードを多く回避できます。これはこのデータリポジトリの実装の詳細を書き込むだけです。また、NoSQL　データベースのような別のデータストレージへの切り替えも非常に簡単です。
====

Spring Data　は、ボイラープレートのコードをたくさん書かなくてもデータにアクセスできる便利な方法を提供してくれます。1 つの方法としては、 _JdbcTemplate_ を使用することです。まず、 _ProductRepository_ のメンバーとして自動で結びつける（autowire）必要があります。 `TODO: Autowire the jdbcTemplate here` の場所に以下を追加します。

[source, java, role="copypaste"]
----
    @Autowired
    private JdbcTemplate jdbcTemplate;
----

_JdbcTemplate_ は _RowMapper_ を提供する必要があります。 これは、クエリの行間をJavaオブジェクトにマッピングできるようにするためです。 _RowMapper_ をこのように定義します。 `<!-- TODO: Add row mapper here -->` の位置に以下を追加します。

[source, java, role="copypaste"]
----
    private RowMapper<Product> rowMapper = (rs, rowNum) -> new Product(
            rs.getString("itemId"),
            rs.getString("name"),
            rs.getString("description"),
            rs.getDouble("price"));
----

これで、ビジネスメソッドを作る準備が整いました。まずは `readAll()` を始めてみましょう。それは `List<Product>` を返す必要があります。 そして、クエリを `SELECT * FROM catalog` のように書けます。 そして、これはrowMapperを使用して `Product` オブジェクトにマッピングします。 `<!-- TODO:Create a method for returning all products -->` の位置に以下を追加します。

[source, java, role="copypaste"]
----
    public List<Product> readAll() {
        return this.jdbcTemplate.query("SELECT * FROM catalog", rowMapper);
    }
----

一つの製品要素を見つける方法も必要です。 `<!-- TODO: Create a method for returning one product -->` の位置に以下を追加します。

[source, java, role="copypaste"]
----
    public Product findById(String id) {
        return this.jdbcTemplate.queryForObject("SELECT * FROM catalog WHERE itemId = ?", new Object[]{id}, rowMapper);
    }
----

これで _ProductRepository_ にはすべてのコンポーネントが含まれているはずです。しかし、データベースに接続する方法を Spring に伝える必要があります。ローカル開発では、H2 のインメモリデータベースを使用します。後で、これを OpenShift にデプロイする際には、本番で使用しているものと一致する PostgreSQL データベースを使用します。

Spring Frameworkには多くのまともなデフォルトがありますが、それは常に時々魔法のように見えることがあります。しかし、基本的にはデータベースドライバをセットアップするためにしなければならないことは、いくつかの設定値を提供することだけです。 `src/main/resources/application-default.properties` を開き、コメントの `#TODO: Add database properties` の位置に以下を追加します。

[source, properties, role="copypaste"]
----
spring.datasource.url=jdbc:h2:mem:catalog;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.username=sa
spring.datasource.password=sa
spring.datasource.driver-class-name=org.h2.Driver
----

Spring Data フレームワークは、クラスパスに `schema.sql` があるかどうかを自動的に確認し、初期化時にそれを実行します。

これで、Spring Data を使ってデータベースからデータを収集する方法と、開発やテストにローカルの H2 データベースを使う方法を見てきました。

このラボの次のステップでは、REST エンドポイントから JSON 形式でデータベースの内容を公開するロジックを追加します。

==== 5.カタログサービスの作成

今度はサービスクラスを作成します。後にサービスクラスは在庫サービスとのインタラクションを制御するものになりますが、今のところは基本的にリポジトリクラスのラッパーに過ぎません。

もう一度、 `src/main/java/com/redhat/coolstore/service` パッケージ内に新しいクラス `CatalogService.java` を作成します。

空のクラスをこのコードで置き換えます。

[source, java, role="copypaste"]
----
package com.redhat.coolstore.service;

import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

//import com.redhat.coolstore.client.InventoryClient;
import com.redhat.coolstore.model.Product;

import org.json.JSONArray;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CatalogService {

    @Autowired
    private ProductRepository repository;

    //TODO: Autowire Inventory Client

    public Product read(String id) {
        Product product = repository.findById(id);
        //TODO: Update the quantity for the product by calling the Inventory service
        return product;
    }

    public List<Product> readAll() {
        List<Product> productList = repository.readAll();
        //TODO: Update the quantity for the products by calling the Inventory service
        return productList;
    }

}
----

ご覧のように、コードの中にはいくつかの `TODO` があります。後でこれらのプレースホルダを使用して在庫クライアントを呼び出して数量を取得するロジックを追加します。

これで、REST サービスを公開するエンドポイントを作成する準備が整いました。

まず、 `src/main/java/com/redhat/coolstore/service` パッケージに `CatalogEndpoint.java` という新しいクラスを作成します。

内容をこのコードに置き換えてください。

[source, java, role="copypaste"]
----
package com.redhat.coolstore.service;

import java.util.List;
import com.redhat.coolstore.model.Product;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/services")
public class CatalogEndpoint {

    private final CatalogService catalogService;

    public CatalogEndpoint(CatalogService catalogService) {
      this.catalogService = catalogService;
    }

    @GetMapping("/products")
    public List<Product> readAll() {
      return this.catalogService.readAll();
    }

    @GetMapping("/product/{id}")
    public Product read(@PathVariable("id") String id) {
      return this.catalogService.read(id);
    }

}
----

Spring MVC フレームワークのデフォルトでは、Java オブジェクトを JSON にシリアライズしたりマッピングしたりするために _Jackson_ が使われています。Jackson は JAX-B を拡張し、単純な Java 構造体を自動的に解析して JSON に、またその逆も可能です。私たちの `Product.java` の事前に作成されたクラスは非常にシンプルです。これには基本的な属性しか含まれていません。Product と JSON の間のパース方法を Jackson に伝える必要はありません。

これでカタログを返すエンドポイントができました。また、サービスを開始してデフォルトのページを再度読み込むこともできます。これで製品が戻ってくるはずです。

CodeReady Workspaces ターミナルから以下のコマンドでアプリケーションを起動します。

[source,sh,role="copypaste"]
----
mvn clean spring-boot:run -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog
----

[NOTE]
====
あなたが利用可能であるポート `8081` についてのポップアップが表示された場合は、単に `X` ボタンでそれを却下します。
====

アプリケーションが起動するのを待ち、 `Started RestApplication in 4.025 seconds (JVM running for 4.361)` のようなログメッセージを取得します。そして、別のターミナルで以下のコマンドを実行してエンドポイントを確認します。

[source,sh,role="copypaste"]
----
curl http://localhost:8081/services/products | jq
----

すべての製品からなる完全な JSON 配列を取得する必要があります。

[source,json]
----
  {
    "itemId": "329299",
    "name": "Red Fedora",
    "desc": "Official Red Hat Fedora",
    "price": 34.99,
    "quantity": 0
  },
  { ... }
----

これで、このラボの 3 番目のステップを正常に実行できました。

これで、Spring MVC で REST アプリケーションを作成し、プロダクトを返すシンプルなアプリケーションを作成する方法を見てきました。

次のステップでは、別のサービスを呼び出して、エンドポイントの応答を在庫の状態を使って強化します。

[NOTE]
====
アプリが起動しているターミナルで kbd:[CTRL-C] をクリックしてサービスを停止してください！
====

==== 6.在庫データの取得

ドメイン駆動設計を使用してアプリケーションをマイクロサービスに再設計する際に、在庫と製品カタログは 2 つの別々のドメインであることがわかりました。しかし、現在の UI では、カタログサービスと在庫サービスの両方からデータを取得することを想定しています。

===== サービスの相互作用

私たちの問題は、 `/services/products` で REST サービスを呼び出す際に、ユーザーインターフェイスが 2 つのサービスからのデータを必要とすることです。以下のように解決する方法が複数あります。

*1.クライアントサイドの統合* - UI を拡張して、最初に `/services/products` を最初に呼び出すように UI を拡張することができます。 そして、各製品アイテムについて `/services/inventory/{prodId}` を呼び出して在庫状況を取得します。その後、Webブラウザで結果を結合します。これが一番邪魔にならない方法だと思います。ところが、100 個の商品があればクライアントは 101 個のリクエストをサーバに行うということにもなります。インターネット接続が遅い場合、問題が発生する可能性があります。

*2.マイクロサービス・ゲートウェイ* - カタログ _サービス_ の前にゲートウェイを作成して、最初にカタログ サービスを呼び出し、そのレスポンスに基づいて在庫を呼び出します。というのも一つの選択肢です。このようにして、クライアントからサーバへの呼び出しをたくさん避けることができます。 http://camel.apache.org[Apache Camel^] はこれを行うための素晴らしい機能を提供しています。これについてもっと知りたい方は、Coolstore Microservices の例をチェックしてみてください: http://github.com/jbossdemocentral/coolstore-microservice[こちら^]

*3.サービス間* - 用途や好みに応じて、サービス間の呼び出しもできます。私たちの場合は、カタログサービスが REST を使用して在庫サービスを呼び出して在庫の状態を取得し、それをレスポンスに含めることを意味します。

ここに正解も不正解もありません。しかし、これは Red Hat Runtimes を使ったアプリケーションの近代化に関するワークショップなので、ここではオプション 1 か 2 を選択することはありません。代わりにオプション 3 を使用して、カタログを拡張して在庫サービスを呼び出すようにします。

==== 7.在庫クライアントの実装

私たちは今、在庫を呼び出すクライアントを作成できるようになりました。Netflix は Spring フレームワークにいくつかの素晴らしい拡張機能を提供しており、そのほとんどは Spring Cloud プロジェクトで獲得されています。しかし、Spring Cloud は主に Pivotal Cloud Foundry にフォーカスしています。そして、そのおかげで Red Hat などは Spring Cloud Kubernetes を Spring Cloud プロジェクトに貢献してきました。これにより、OpenShift のような Kubernetes ベースのプラットフォームでも同様の機能性が得られます。

在庫クライアントは _Feign_ と呼ばれる Netflix プロジェクトを使用します。これは、標準的なコードを書かなくても済むようにするための良い方法を提供してくれます。Feign はまた、Hystrix と統合されているため、機能しない呼び出しをサーキットブレイクすることができます。これについては後ほど詳しく説明しますが、まずは在庫クライアントの実装から始めましょう。Feignを使って、どのようなパラメータと戻り値の型を想定しているのかを詳細に記述したインターフェースを作成するだけです。そして、 `@RequestMapping` でアノテーションして詳細を提供し、 `@Feign` でインターフェースをアノテーションして名前を提供します。

プロジェクトエクスプローラの `src/main/java/com/redhat/coolstore/client/` パッケージに `InventoryClient.java` クラスを作成します。

ファイルに以下のコードを追加します。

[source, java, role="copypaste"]
----
package com.redhat.coolstore.client;

import feign.hystrix.FallbackFactory;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@FeignClient(name="inventory")
public interface InventoryClient {

    @RequestMapping(method = RequestMethod.GET, value = "/services/inventory/{itemId}", consumes = {MediaType.APPLICATION_JSON_VALUE})
    String getInventoryStatus(@PathVariable("itemId") String itemId);

    //TODO: Add Fallback factory here

}
----

`src/main/resources/application-default.properties` ファイルを開きます。これらのプロパティを `#TODO: Configure netflix libraries` の位置に追加します。

[source, java, role="copypaste"]
----
inventory.ribbon.listOfServers=inventory.{{ USER_ID }}-inventory.svc.cluster.local:8080
feign.hystrix.enabled=true
----

`inventory.ribbon.listOfServers` を設定することで、サービスの実際の URL を `{{ USER_ID }}-inventory.svc.cluster.local:8080` (前回のラボで作成した在庫のマイクロサービスを指します) にハードコーディングしています。複数のサーバがある場合は、カンマを使って追加できます。しかし、Kubernetesを使用して、ここに複数のエンドポイントをリストアップする必要はありません。Kubernetesには、同じサービスの複数のインスタンス間を内部的にルーティングする _Services_ の概念があります。

今、我々は我々の _CatalogService_ でそれを使用できるクライアントを持っています。

_src/main/java/com/redhat/coolstore/service/CatalogService.java_ を開きます。

そして、 `//TODO: Autowire Inventory Client` の位置に以下を追加することで、その中にクライアントを自動で結びつけ（注入など）ます。

[source, java, role="copypaste"]
----
    @Autowired
    private InventoryClient inventoryClient;
----

次に、 `read(String id)` メソッドを更新します。 `//TODO: Update the quantity for the product by calling the Inventory service` の位置に以下を追加します。

[source, java, role="copypaste"]
----
        JSONArray jsonArray = new JSONArray(inventoryClient.getInventoryStatus(product.getItemId()));
        List<String> quantity = IntStream.range(0, jsonArray.length())
            .mapToObj(index -> ((JSONObject)jsonArray.get(index))
            .optString("quantity")).collect(Collectors.toList());
        product.setQuantity(Integer.parseInt(quantity.get(0)));
----

また、InventoryClient の上部近くのインポート文のコメントを外して、インポート文を追加することを忘れないでください。

[source, java]
----
import com.redhat.coolstore.client.InventoryClient;
----

また、 _readAll()_ メソッドでは、 `//TODO: Update the quantity for the products by calling the Inventory service` の位置に以下を追加します。

[source, java, role="copypaste"]
----
        productList.forEach(p -> {
          JSONArray jsonArray = new JSONArray(this.inventoryClient.getInventoryStatus(p.getItemId()));
          List<String> quantity = IntStream.range(0, jsonArray.length())
            .mapToObj(index -> ((JSONObject)jsonArray.get(index))
            .optString("quantity")).collect(Collectors.toList());
          p.setQuantity(Integer.parseInt(quantity.get(0)));
        });
----

[NOTE]
====
クラス `JSONArray` は、値の順序付けされたシーケンスです。その外部テキスト形式は、値をコンマで区切って角括弧で括った文字列です。その内部形式は、インデックスで値をアクセスするための get メソッドと opt メソッド、値の追加や置換を行うための element メソッドを持つオブジェクトです。
====

==== 8.在庫のフォールバック（頼みの綱）を作成

前のステップでは、在庫サービスを呼び出すクライアントを追加しました。サービスを呼ぶサービスは、マイクロサービスアーキテクチャではよくあることです。ですが、サービスを増やしていくと、問題が発生する可能性が飛躍的に高まります。各サービスが99.9%更新されていたとしても、100のサービスがあったら、推定の起動している時間は 90% 程度にしかなりません。そのため、失敗したときのための計画を立てる必要があります。そして、アプリケーションロジックは依存するサービスが応答しないことを考慮しなければなりません。

前のステップでは、NetflixのクラウドネイティブライブラリのFeignクライアントを使用して、REST呼び出しを行うためのボイラプレートコードを書かなくても済むようにしました。しかし、Feign にはフォールバックロジックが簡単に作れるというもう一つの良い特性があります。この場合、フォールバックのロジックを別のクラスではなくクライアントの一部にしたいので、static inner class を使用します。

`InventoryClient` では、 `//TODO: Add Fallback factory here` の位置に以下を追加します。

[source, java, role="copypaste"]
----
    @Component
    class InventoryClientFallbackFactory implements FallbackFactory<InventoryClient> {
      @Override
      public InventoryClient create(Throwable cause) {
        return itemId -> "[{'quantity':-1}]";
      }
    }
----

フォールバックファクトリーを作成した後は、問題が発生した場合にそのフォールバックを使用するようにFeignに指示し、 `@FeignClient` アノテーションにfallbackFactoryプロパティを追加します。既存の `@FeignClient(name="inventory")` の行を以下の様に置き換えます。

[source, java, role="copypaste"]
----
@FeignClient(name="inventory",fallbackFactory = InventoryClient.InventoryClientFallbackFactory.class)
----

=== 9.サービスの動作が遅い


フォールバックを持つことは良いことですが、そのためには、依存するサービスが正しく応答していないことを正しく検出する必要があります。サービスが応答しないことに加えて、サービスの応答が遅くなることもあり、当社のサービスも応答が遅くなります。これにより、デバッグやピンポイントでの問題の特定が困難なカスケード問題が発生する可能性があります。したがって、我々のサービスにもまともなデフォルトを持つべきである。デフォルトを設定に追加することで、デフォルトを追加することができます。

`src/main/resources/application-default.properties` を開きます。

そして、 `#TODO: Set timeout to for inventory` の位置に以下を追加します。

[source, java, role="copypaste"]
----
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=20000
----

ローカルでアプリを再テストしてみましょう。アプリを再ビルドして再実行します。

[source,sh,role="copypaste"]
----
mvn clean spring-boot:run -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog
----

その後、別のターミナルで再度製品カタログにアクセスします。

[source,sh,role="copypaste"]
----
curl http://localhost:8081/services/products | jq
----

以下が直ぐに見られるでしょう。

[source,json]
----
  {
    "itemId": "444437",
    "name": "Lytro Camera",
    "desc": "Consumers who want to up their photography game are looking at newfangled cameras like the Lytro Field camera, designed to take photos with infinite focus, so you can decide later exactly where you want the focus of each image to be.",
    "price": 44.3,
    "quantity": 230
  }
----

`"quantity":230` に注目して下さい - CodeReady Workspaces は OpenShift クラスタで動作しているため、先に設定した `inventory.ribbon.listOfServers` の値は完全に有効です。

おめでとう！これで、製品カタログから製品を取得し、外部サービスの在庫データでデータを充足させるためのフレームワークが完成しました。このラボの次のステップでは、アプリケーションを OpenShift Container Platform にデプロイします。そして、クラウドネイティブマイクロサービス開発の様々な側面をケアするための追加機能の追加を開始します。

==== 10.OpenShift にデータベースを追加

我々の本番のカタログマイクロサービスは、在庫データを格納するために外部データベース （PostgreSQL） を使用します。あなたのために `{{ USER_ID}}-catalog` プロジェクトを作成しました。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-catalog[Topology View for {{ USER_ID }}-catalog project^] にアクセスしてみてください。

プロジェクト概要の _Database_ ボックスの左側にある **+Add** をクリックします。

image::db-catalog.png[db, 700]

検索ボックスに `postgres` と入力し、 *PostgreSQL (ephemeral)* をクリックします。

image::db-catalog-postgres.png[db, 700]

*Instantiate Template* をクリックして、以下のフィールドを入力します。他のものはデフォルト値のままにします。

* **Namespace** : _最初の名前空間は `{{ USER_ID }}-catalog` を選択します。 2 つ目は `openshift` のままにしておきます。_
* **Database Service Name** : `catalog-database`
* **PostgreSQL Connection Username** : `catalog`
* **PostgreSQL Connection Password** : `mysecretpassword`
* **PostgreSQL Database Name** : `catalog`

image::db-catalog-postgres-fields.png[db, 700]

これにより、データベースがカタログプロジェクトにデプロイされます。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-catalog[Topology View^] をクリックすると表示されます。

==== 11.本番設定の追加

CodeReady Workspaces の `src/main/resources` に `application-openshift.properties` という名前の新しいファイルを作成します。

[NOTE]
====
新しいファイルは、既存の `application-default.properties` と同じディレクトリにあることを確認してください！
====

このファイルに以下の内容を追加します。

[source, properties, role="copypaste"]
----
# Production
server.port=8080
spring.datasource.url=jdbc:postgresql://catalog-database:5432/catalog
spring.datasource.username=catalog
spring.datasource.password=mysecretpassword
spring.datasource.initialization-mode=always
spring.datasource.initialize=true
spring.datasource.schema=classpath:/schema.sql
spring.datasource.continue-on-error=true

feign.hystrix.enabled=true
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=20000
inventory.ribbon.listOfServers=inventory.{{ USER_ID }}-inventory.svc.cluster.local:8080
----

このファイルは OpenShift にデプロイする際に Spring _プロファイル_ を指定して使用します。

==== 12.ビルドとデプロイ

ローカルアプリを起動している場合は、ターミナルで kbd:[CTRL-C] と入力して停止してください。

ターミナルで以下のコマンドを使用してプロジェクトをビルドし、デプロイします。

[source,sh,role="copypaste"]
----
mvn clean install spring-boot:repackage -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog
----

ビルド出力の最後に *BUILD SUCCESS* が表示されるはずです。

次に、CodeReady Workspaces ターミナルで以下のコマンドを使用してプロジェクトをデプロイします。

[source,sh,role="copypaste"]
----
oc project {{ USER_ID }}-catalog && \
oc new-build registry.access.redhat.com/ubi8/openjdk-11 --binary --name=catalog-springboot -l app=catalog-springboot
----

そして、ビルドを開始して、1分ほどで完成するビルドを見てみましょう。

[source,sh,role="copypaste"]
----
oc start-build catalog-springboot --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog/target/catalog-1.0.0-SNAPSHOT.jar --follow
----

ビルドが完了したら、OpenShift アプリケーションとしてデプロイし、スプリングプロファイルをオーバーライドして _本番_ の値を使用します。

[source,sh,role="copypaste"]
----
oc new-app catalog-springboot -e JAVA_OPTS_APPEND='-Dspring.profiles.active=openshift'
----

を実行してサービスを世界に公開し、ヘルスチェックを追加します。

[source,sh,role="copypaste"]
----
oc expose service catalog-springboot && oc set probe dc/catalog-springboot  --readiness --get-url=http://:8080 --initial-delay-seconds=5 --period-seconds=5 --failure-threshold=15

----

最後に、実際に入れ替わりが完了したことを確認してください。カタログは {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-catalog[Topology View^] にアクセスして、青丸を確実に確認しましょう！

そして、 http://catalog-springboot-{{ USER_ID }}-catalog.{{ ROUTE_SUBDOMAIN}}[Catalog Web frontend^] にアクセスして、期待された在庫量（そして `-1` ではない）を取得していることを確認します。

image::catalog.png[catalog, 700]

*おめでとう！* 在庫データを取得するために在庫サービスを呼び出すカタログサービスをマイクロサービスとしてデプロイしました。

==== 13.モノリスを抑制

今のところ、 https://www.martinfowler.com/bliki/StranglerApplication.html[モノリスを抑制^] を始めていません。OpenShift に入ってくる各外部リクエストは（今のように ingress を使用していない限り）Route を通過します。私たちのモノリスでは、ウェブページはクライアント側の REST 呼び出しを使用してページの異なる部分をロードします。

ホームページでは、製品リストが `/services/products` への REST 呼び出しで読み込まれます。現時点では、その URL への呼び出しは、モノリス内の製品カタログにまだアクセスします。ここで、これらの呼び出しを、代わりに新しく作成したカタログサービスにルーティングして、次のような結果にします。

image::catalog-goal.png[Greeting, 700]

以下の手順に従って、 *オリジン間リソース共有 （CORS）* ベースのルートを作成します。CORS は、Web ページ上の制限されたリソースを、最初のリソースが提供されたドメイン以外の別のドメインから要求できるようにするメカニズムです。

Quarkus には、 _javax.servlet.Filter_ インターフェイスを実装した _CORS フィルター_ が付属しており、すべての受信 HTTP リクエストを遮断します。これは Quarkus の設定ファイルで有効にできます。 `src/main/resources/application.properties` ファイル内の `在庫` プロジェクト先に作成した Quarkus アプリ）に以下の行を追加します。

[source, properties, role="copypaste"]
----
%prod.quarkus.http.cors=true
----

このコマンドを使用して *在庫* アプリケーションを再ビルドして再デプロイします（このコマンドは OpenShift Quarkus 拡張機能を再び使用してデプロイします）。

[source,sh,role="copypaste"]
----
oc project {{USER_ID}}-inventory && \
mvn clean package -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/inventory -DskipTests
----

1 分ほどで完了します。ビルドが完了すると、在庫ポッドは OpenShift の DeploymentConfig トリガーを介して自動的にデプロイされます。

モノリス・アプリケーションの _製品_ ページで制限されたリソースを許可するために、 `catalog` プロジェクトの `src/main/java/com/redhat/coolstore/service` で `CatalogEndpoint` クラスを開きます。クラスレベルのアノテーションを以下の様に置き換えます。

[source, java, role="copypaste"]
----
@CrossOrigin
@RestController
@RequestMapping("/services")
----

単純に `@CrossOrigin` アノテーションを追加しただけです。

以下のコマンドを使用して *カタログ* サービスを再ビルドし、再デプロイします。

[source,sh,role="copypaste"]
----
mvn clean install spring-boot:repackage -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog && \
oc start-build -n {{ USER_ID }}-catalog catalog-springboot --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/catalog/target/catalog-1.0.0-SNAPSHOT.jar --follow
----

1 分ほどで完了します。ビルドが完了すると、カタログポッドは OpenShift の DeploymentConfig トリガーを経由して自動的にデプロイされます。

モノリスアプリケーションのカタログエンドポイントを更新してみましょう。 *monolith* プロジェクトで `src/main/webapp/app/services` の `catalog.js` を開きます。画像のように `factory.getProducts = function()` 行の直前に `baseUrl` の値を定義する行を追加します。

[source,javascript,role="copypaste"]
----
baseUrl='http://catalog-springboot-{{ USER_ID }}-catalog.{{ ROUTE_SUBDOMAIN }}/services/products';
----

image::catalog_js_strangler.png[strangler, 700]

CodeReady Workspaces Terminal で *モノリス* プロジェクトを再ビルドし、再デプロイします。

[source,sh,role="copypaste"]
----
mvn clean package -DskipTests -Popenshift -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith && \
oc start-build -n {{ USER_ID }}-coolstore-dev coolstore --from-file $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m1-labs/monolith/deployments/ROOT.war --follow
----

ビルドが完了すると、CoolStore ポッドは OpenShift の DeploymentConfig トリガーを経由して自動的にデプロイされます。 {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-coolstore-dev[Monolith Topology^] にアクセスしてロールアウトされていることを確認し、青い丸を待ちましょう！

==== 14.UI をテスト

ルート URL アイコン（CoolStore モノリスの青丸の右上にある矢印）をクリックしてモノリスの UI を開きます。

新しいカタログがモノリスと一緒に使われていることを確認してください。

image::coolstore-web.png[Greeting, 700]

適正な在庫があれば、画面は同じようになります。しかし、以前の製品である _Atari 2600 Joystick_ は、私たちの新しいカタログマイクロサービスで削除されたため、今ではなくなっていることに注意してください。

[NOTE]
====
Web ページが変わらない場合は、Web ブラウザのクッキーとキャッシュをクリーンアップしてください。
====

==== おめでとうございます！

モノリスを _抑制する_ ことに成功しました。モノリスの機能の一部（在庫とカタログ）がマイクロサービスとして実装されるようになりました。

==== まとめ

このラボでは、Spring Boot を使った開発と OpenShift との併用について少し詳しく学びました。

モノリシック CoolStore アプリケーションに実装されていた機能を表す新しい製品カタログマイクロサービスを作成しました。また、この新サービスは在庫サービスと通信して、各製品の在庫状況を取得します。
